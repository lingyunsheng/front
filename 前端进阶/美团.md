# js 继承，优缺点，怎么改进封装
**原型链继承**
原型链继承 可以继承父类原型上的属性和方法 ，无法向父类构造函数传参，当子类实例修改了属性，但是继承父类的所有的子类实例也会发生改变，无法实现复用 让子类的原型对象 指向父类的实例对象
```js
function person(name,age) {
    this.name=name
    this.age=age
}
person.prototype.say=function() {
    console.log(`${this.name} is working`)
}
function man() {}
man.prototype = new person();
var p = new man();
p.prototype=person
// p.name='ww'
// p.age=19
// p.say() ww is working
```

**构造函数继承**
可以向父类传参，而且不能继承父类原型上添加的属性和方法，借助call实现继承父类上的属性，当子类实例发生改变的时候，不会影响其他子类实例，避免引用类型的属性被其他所有实例共享，每次都得定义
```js
function person(name,age) {
    this.name=name
    this.age=age
}
function man(sex) {
    person.call(this,name)
    this.sex=sex;
}
var p = new man('ww',19,'女')
console.log(p)
```

**原型链构造组合继承**
调用了两次父类 可以向父类构造函数传参，可以继承原型上的属性和方法，无法实现复用 
```js
function person(name,age) {
    this.name=name
    this.age=age
}
person.prototype.say=function() {
    console.log(`${this.name} is working`)
}
function man(name,sex) {
    person.call(this,name)
    this.sex=sex;
}
man.prototype=new person();
var p = new man('w',19,'女')

```
**原型式继承**
将传入的对象作为创建的对象的原型,缺点，子类修改属性会导致所有实例共享
```js
function createNewObj(o) {
    function F() {}
    F.prototype=o;
    return new F();
}
```
// Object.create()方法
```js
function create(o) {
    // 定义一个函数
    function F() {}
    // 传入的对象
    F.prototype=o;
    return new F();
}
```
// 原型继承
```js
function createObj(o) {
    function F() {}
    F.prototype=o;
    return new F();
}

let person = {
    name:'www',
    hobby:['sss','sss']
}
let p1 = createObj(person)
let p2 = createObj(person)

console.log(p1.name,p1.hobby) www ['sss','sss']
console.log(p1.name,p1.hobby)  www ['sss','sss']

person1.name = "xixi";
person1.hobbies.push("basketball");

console.log(person1.name,person1.hobbies) //xixi ["sing", "dance", "rap", "basketball"]
console.log(person2.name,person2.hobbies) //JoseyDong ["sing", "dance", "rap", "basketball"]

```
**寄生继承**
创建一个用于封装继承过程的函数，该函数在内部以某种形式来增强函数，返回对象,
用寄生方式继承可以为对象添加函数，和构造函数一样，每次都要创建一边方法 缺点无法复用
```js
function createObj(o) {
    let obj = Object.create(o);
    // 封装继承过程的函数
    o.sayName= function() {
        console.log('hi')
    }
    return o;
}

let person = {
    name:'www',
    hobbies:['ss','ssss']
}

let p = createObj(o)
p.sayName() // hi


```
**寄生组合继承**
可以实现复用，可以传参，只调用了一次父类的构造函数，避免在父类原型上创建不必要的多余的属，与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。
```js
function person(name,age) {
    this.name=name
    this.age=age
}
person.sayHello= function() {
    console.log('hello');
}
person.prototype.sayName= function() {
    console.log(`${this.name} `)
}
function man(name,sex) {
    person.call(this,name);
    this,sex=sex;
}

// 使用一个F空函数当子类和父类的媒介，防止修改子类的原型对象影响到父类的实例
let F = function() {}
F.prototype=person.prototype;
man.prototype = new F();

let obj = Object.create(person.prototype)
man.prototype = obj;


let p = new man('sss',19)
console.log(p)
// {name:'sss',age:19}
```
// 封装一下继承的方法
```js
function createObj(o) {
    function F() {}
    F.prototype=o;
    return new F();
}

function prototype(child, parent) {
    let prototype = Object.create(parent.prototype);
    prototype.constructor=child;
    child.prototype=prototype
}

prototype(Child, Parent);
```


**ES6继承**
子类必须在conrutor构造器中调用super方法，子类没有this对象，是继承父类的this对象
```js
class Person {
    constructor(name) {
        this.name=name;
    }

    logName() {
        console.log(`my name is ${this.name}`)
        return `my name is ${this.name}`
    }
}
class p extends Person {
    constructor(name,age) {
        super(name);
        this.age=age;
    }
    logAll() {
        console.log(`my name is ${this.name} and age is ${this.age}`);
        return this.age;
    }
}
var person = new person('parent')
console.log(person) // person: Person{name:'parent'}
var p = new P('ww',18)
console.log(p) // p: P{name:'ww', age:18}
```
方法二
```js
// ES6 

class parents {
    constructor(){
        this.grandmather = 'rose';
        this.grandfather = 'jack';
    }
}

class children extends parents{
    constructor(mather,father){
    //super 关键字，它在这里表示父类的构造函数，用来新建父类的 this 对象。
        super();
        this.mather = mather;
        this.father = father;
    }
}

let child = new children('mama','baba');
console.log(child) // =>
// father: "baba"
// grandfather: "jack"
// grandmather: "rose"
// mather: "mama"
```

# 能不能说下TCP和UDP的区别

**TCP是面向连接的，安全的可靠的稳定的基于字节流的传输层协议**
**UDP是面向无连接的，不可靠的的传输层协议**

和UDP相比，TCP有三大特性：
**面向连接。客户端和服务端的连接，在建立通信之前，需要三次握手建立连接，而UDP没有相应的建立连接的过程**
**可靠性。TCP连接有状态，可以控制，TCP会精准记录哪些数据发送了，哪些被接收了，有状态，可靠性**
**面向字节流。UDP的数据传输是基于数据报的，传输数据大，不稳定，不可靠容易丢包，TCP为了维护状态采用的是字节流传输，将一个个的IP包变成了字节流**
**TCP是单广播系统，只支持一对一，而UDP是多通道的广播系统，传输过程中支持多对多一对一，一对多**

# tcp 为什么是三次握手、四次挥手
对应到 TCP 的三次握手，也是需要确认双方的两样能力: 发送的能力和接收的能力。于是便会有下面的三次握手的过程:

最开始，客户端和服务器端都处于CLOSED状态，然后服务器端开始监听端口，进入LISTEN阶段

第一次握手：客户主动发起连接，发送一个SYN报文字段，自己进入了SYN——SENT，
同时还会发送一个序列号，随机生成的字符串

第二次握手，服务器端可以接收到客户端发送的连接，返回了一个SYN+ACK确认应答，表示服务端已经收到了客户端的消息，服务器端进入了SYN_RECIEVE

第三次握手，客户端再发送ACK给服务器端，自己进入了ESTABLISHED状态，服务端收到ACK包，也进入ESTABLISHEAD状态

另外需要提醒你注意的是，从图中可以看出，SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加1，为什么呢？只需要记住一个规则:

SYN需要消耗一个序列号，凡是需要对端进行确认的时候，一定要消耗TCP报文的序列号

**凡是需要对端确认的，一定消耗TCP报文的序列号。SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。**

**两次握手无法确认客户端的接受能力，如果是两次握手，如果客户端断开了，就会导致资源浪费，需要消息重传**


**四次握手：三次握手是确认客户端和服务器端双方都具备发送和接受的能力，四次是建立在三次握手基础上的**

# 四次挥手

刚开始客户端和服务端都处于ESTABLISHED状态

第一次挥手，客户端要主动发起断开关闭连接的请求，向服务端发送FIN报文，客户端进入FIN_WAIT状态，进入版关闭转台，客户端不会发送数据了，只能接收数据

第二次挥手，服务器端接收到客户端FIN关闭连接请求，会向客户端发送一个ACK确认包确认，进入CLOSED_WAIT状态

第三次挥手，服务端发送FIN关闭连接请求，发送完剩余的数据

第四次挥手，客户端收到了服务端确认关闭连接请求，进入TIME_WAIT阶段，继续接收完服务端发送到数据，2个MSL（报文最大生存时间），然后挥手成功。

**等待2MSL的意义**
如果不等待会怎样？
如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。
那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?

1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达

这就是等待 2MSL 的意义。

**为什么是四次挥手而不是三次**
因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。
如果是三次挥手会有什么问题？
等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。


# js 跨域方法

**同源策略：浏览器最核心最基本的安全功能，如果少了同源策略，浏览器很容易遭受到XSS，CSRF等攻击，同源策略就是“协议+域名+端口”一致就是同源，如果两个不同的域名指向一个ip地址，也不是同源**

http://   www  .     abc.com   : 8080     /  scripts/jquery.js
协议      子域名       主域名     端口号          请求资源地址

**同源策略限制的内容**
- cookie、LocalStorage，IndexDB等存储型内容
- DOM节点
- AJAX请求发送

**有三个标签允许跨域加载资源**
- img
- link href
- script标签的src

**常见的跨域场景**

当协议，子域名，主域名，端口号不一致的时候，都不能算作同源，不同域之间相互请求资源，就算作**跨域**

http://www.a.com/a.js         同一域名下     允许通信
http://www.a.com/b.js

http://www.a.com/lab/a.js     同一域名下不同文件夹   允许通信
http://www.a.com/script/b.js


协议和端口不一致造成的跨域问题，前台无能为力

在跨域问题上仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。

**跨域并不是请求发不出去，请求可以发出去，服务端能够收到请求，并且正常返回结果，只是被浏览器拦截了**

通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了


表单可以发起跨域请求，但是浏览器会拦截响应，所以表单不会获取最新的内容，跨域不能完全阻止CSRF，请求已经发出去了

跨域解决方案如下所示。

## JSONP

**JSONP原理：利用<script></script>标签src不受跨域限制的漏洞，网页可以得到其他来源动态生成的JSONP数据，JSONP请求一定要对方的服务器支持才行**

JSONP和AJAX对比：JSONP和AJAX都相同，都是客户端向服务器端发送请求，从服务器端接收响应获取数据的方式，AJAX属于同源的方式，而JSONP属于非同源，跨域请求

**JSONP优缺点**：JSONP优点是兼容性好简单，可以解决主流浏览器的跨域资源数据访问的问题，缺点是只支持GET方法，具有局限性，不安全，容易遭受XSS攻击

**JSONP的实现流程**
- 声明一个回调函数，函数名show当作参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据，就是服务器返回的data
- 创建一个script标签，把跨域的API数据接口地址，赋值给script的src，还要在这个地址中间向服务器传递函数名(通过问好传参:?callback=show)
  - 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是show('我不爱你')。
- 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show）对返回的数据进行操作

**JSONP函数**

```js
function jsonp({url,params,callback}) {
    return new Promise((resolve,reject) => {
        // 创建一个script标签
        let script = document.createElement('script');
        window[callback] = function(data) {
            resolve(data);
            // 回调接收数据
            document.body.removeChild(script);
        }
        // wd=b&callback=show
        params:{...params,callback};
        let arr = [];
        for(let key in params) {
            arr.push(`${key}=${params.key}`)
        }
        script.src="`${url}?${arr.join('&')}`
        document.body.appendChild(script)
    })
}

jsonp({
    url:'http://localhost:3000/say',
    params:{wd:'iloveyou'},
    callback:'show'
}).then(data => {
    console.log(data)
})

```

**自己手写**

```js
function jsonp({url,params,callback}) {
    return new Promise((resolve, reject) => {
        let script = document.createElement('script')
        // 回调拼接
        window[callback] = function(data) {
            resolve(data);
            document.body.removeChild(script)
        }
        // 拼接这个回调
        let params ={...params, ...url}
        let arr =[]
        for(let key in params) {
            arr.push(`${key} =${params.key}`)
        }
        // scrippt src
        script.src=`${url}?${arr.join('&')}`
        document.body.appendChild(script)
    })
}

jsonp({
    url:'http://localhost:3300',
    params:'dsss',
    callback:'show'
}).then(data => {
    console.log(data)
})
```

http://localhost:3000/say?wd=Iloveyou&callback=show

后台express

```js
var express = require('express')
var app = express()
app.get('say', function(req, res) {
    var {wd, callback} = req.query
    console.log(wd) // i love you
    console.log(callback) // show
    res.send(`${callback}('ssss'`)
})
app.listen(3000)


```

**JQUERY的JSONP形式**
JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存
```js
$.ajax({
url:"http://crossdomain.com/jsonServerResponse",
dataType:"jsonp",
type:"get",//可以省略
jsonpCallback:"show",//->自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略
jsonp:"callback",//->把传递函数名的那个形参callback，可省略
success:function (data){
console.log(data);}
});

```

## CORS

**CORS：cross origin resoucse share：跨域资源共享：需要浏览器和后端同时支持，IE8，9需要XDomainRequest来实现，浏览器会自动进行CORS通信，后端设置Acess-Control-Allow-Origin开启CORS，表示哪些域名可以访问资源**

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。
服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。


1) 简单请求
只要同时满足以下两大条件，就属于简单请求
条件1：使用下列方法之一：
GET
HEAD
POST
条件2：Content-Type 的值仅限于下列三者之一：
text/plain
multipart/form-data
application/x-www-form-urlencoded
请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。
2) 复杂请求
不符合以上条件的请求就肯定是复杂请求了。
复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。
我们用PUT向后台请求时，属于复杂请求，后台需做如下配置：

后台可以设置前端发送请求到时候，哪些域名方法可以访问资源
```js
res.setHeader('Access-Control-Allow-Methods', 'PUT')
// 预检的存活时间
res.setHeader('Access-Control-Max-Age', 6)
// OPTIONS请求不做任何处理
if (req.method === 'OPTIONS') {
  res.end() 
}
// 定义后台返回的内容
app.put('/getData', function(req, res) {
  console.log(req.headers)
  res.end('我不爱你')
})
```

接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段

```js
// index.html
let xhr = new XMLHttpRequest()
document.cookie = 'name=xiamen' // cookie不能跨域
xhr.withCredentials = true // 前端设置是否带cookie
xhr.open('PUT', 'http://localhost:4000/getData', true)
xhr.setRequestHeader('name', 'xiamen')
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4) {
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {
      console.log(xhr.response)
      //得到响应头，后台需设置Access-Control-Expose-Headers
      console.log(xhr.getResponseHeader('name'))
    }
  }
}
xhr.send()
//server1.js
let express = require('express');
let app = express();
app.use(express.static(__dirname));
app.listen(3000);
//server2.js
let express = require('express')
let app = express()
let whitList = ['http://localhost:3000'] //设置白名单
app.use(function(req, res, next) {
  let origin = req.headers.origin
  if (whitList.includes(origin)) {
    // 设置哪个源可以访问我
    res.setHeader('Access-Control-Allow-Origin', origin)
    // 允许携带哪个头访问我
    res.setHeader('Access-Control-Allow-Headers', 'name')
    // 允许哪个方法访问我
    res.setHeader('Access-Control-Allow-Methods', 'PUT')
    // 允许携带cookie
    res.setHeader('Access-Control-Allow-Credentials', true)
    // 预检的存活时间
    res.setHeader('Access-Control-Max-Age', 6)
    // 允许返回的头
    res.setHeader('Access-Control-Expose-Headers', 'name')
    if (req.method === 'OPTIONS') {
      res.end() // OPTIONS请求不做任何处理
    }
  }
  next()
})
app.put('/getData', function(req, res) {
  console.log(req.headers)
  res.setHeader('name', 'jw') //返回一个响应头，后台需设置
  res.end('我不爱你')
})
app.get('/getData', function(req, res) {
  console.log(req.headers)
  res.end('我不爱你')
})
app.use(express.static(__dirname))
app.listen(4000)
```

前端发起请求的时候可以设置是否携带with-credentials，设置访问头 域名 方法等等
上述代码由http://localhost:3000/index.html向http://localhost:4000/跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。

```js
var xhr = new XMLHttpRequest();
document.coolie='name=xx'
xhr.withCredentials=true // 是否携带cookie
xhr.open('put','https:/localhost:8080/getData', true)
xhr.setRequestHeader('name', 'xx')
xhr.onReadyStatechange = function() {
    if(xhr.status===200 && xhr.readyState===4) {
        console.log(xhr.responseTxt)
        console.log(xhr.getResponseHeader('name'))
    }
}
xhr.send()

```

**https://www.fundebug.com/?utm_source=liao BUG检测工具FunDebug**

## postMessage

**postMessage:是HTML5新增的一个特性 HTML5 XML HttpRequest Level2 新增的一个API，用域跨域。页面和其他打开的窗口数据传递，多窗口数据传递，页面和嵌套的iframe消息传递**


- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

**postMessage()方法允许来源不同脚本采取异步的方式进行有效的通信，可以实现跨文档，多窗口，跨域消息的传递**

```js
otherWindow.postMessage(message,targetOrigin, [transfer]);
```
- message: 要传递给其他window的数据
- targetOrigin：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。
- transfer:是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。

**场景**
http://localhost:3000/a.html 和 http://localhost:8080/b.html 传递消息

a.html

**发送数据**
frame.contentWindow.postMessage
**返回数据接收数据**
window.onmessage = function(e) {
    e.data
}
**另一个页面发送数据**
e.source.postMessage('www', e.origin)

```js
<iframe src="http://localhost:8080/b.html" frameborder="0" id="frame" onload="load()"></iframe> // 等加载完出发一个事件
// 内嵌在http://localhost:3000/a.html页面

<script>
    function onload() {
        let frame = document.getElementByID('frame')
        frame.contentWindow.postMessage('i love you', 'http://localhost:8080')// 发送数据
        // 接收返回数据
        window.onmessage = function(e) {
            console.log(e.data)
        }
    }
</script>

// b.html

window.onmessage= function(e) {
    console.log(e.data)
    e.source.postMessage('我不爱你', e.origin);
}

```


## WebSocket
Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。
原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。
我们先来看个例子：本地文件socket.html向localhost:3000发生数据和接受数据
```js
socket.open= function() {
    socket.send()
}
socket.onmessage= function(e) {

}
```
区别于

```js
frame.contentWindow.postMessage('sss','http')
  window.onmessage = function(e) {
            console.log(e.data)
        }

```

```js
<script>
    let socket = new WebSocket('http://localhost:3000')
    socket.open = function() {
        socket.send('i love you')// 向服务端发送数据
    }
    socket.onmessage -= function(e) {
        console.log(e.data) // 接收数据
    }
</script>

// 服务端 server.js
var express = require('express');
var app = express();
var WebSocket = require('ws') // ws websocket ws安装
var wss = new WebSocket.server({port:3000});
wss.on('connection', function(ws) {
    ws.on('message', function(data) {
        console.log(data)
        ws.send('i hate you');
    })
})

```


## Node中间件代理两次跨域
**实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。客户端发送请求，将请求转发给服务器，服务器拿到相应的数据，再转发给客户端**
代理服务器，需要做以下几个步骤：
- 接受客户端请求 。
- 将请求 转发给服务器。
- 拿到服务器 响应 数据。
- 将 响应 转发给客户端。

我们先来看个例子：本地文件index.html文件，通过代理服务器http://localhost:3000向目标服务器http://localhost:4000请求数据。

```js
// index.html(http://127.0.0.1:5500)
 <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
    <script>
      $.ajax({
        url: 'http://localhost:3000',
        type: 'post',
        data: { name: 'xiamen', password: '123456' },
        contentType: 'application/json;charset=utf-8',
        success: function(result) {
          console.log(result) // {"title":"fontend","password":"123456"}
        },
        error: function(msg) {
          console.log(msg)
        }
      })
     </script>
// server1.js 代理服务器(http://localhost:3000)
const http = require('http')
// 第一步：接受客户端请求
const server = http.createServer((request, response) => {
  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段
  response.writeHead(200, {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': '*',
    'Access-Control-Allow-Headers': 'Content-Type'
  })
  // 第二步：将请求转发给服务器
  const proxyRequest = http
    .request(
      {
        host: '127.0.0.1',
        port: 4000,
        url: '/',
        method: request.method,
        headers: request.headers
      },
      serverResponse => {
        // 第三步：收到服务器的响应
        var body = ''
        serverResponse.on('data', chunk => {
          body += chunk
        })
        serverResponse.on('end', () => {
          console.log('The data is ' + body)
          // 第四步：将响应结果转发给浏览器
          response.end(body)
        })
      }
    )
    .end()
})
server.listen(3000, () => {
  console.log('The proxyServer is running at http://localhost:3000')
})
// server2.js(http://localhost:4000)
const http = require('http')
const data = { title: 'fontend', password: '123456' }
const server = http.createServer((request, response) => {
  if (request.url === '/') {
    response.end(JSON.stringify(data))
  }
})
server.listen(4000, () => {
  console.log('The server is running at http://localhost:4000')
})
```
上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出{"title":"fontend","password":"123456"}

## nginx反向代理

**nginx原理：搭建一个中转的nginx服务器，将后端的接口放到前端的api文件，修改nginx的配置即可使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。**
先下载nginx，然后将nginx目录下的nginx.conf修改如下:https://www.cnblogs.com/fundebug/p/10329202.html

```js
// proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;
    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
// 最后通过命令行nginx -s reload启动nginx
// index.html
var xhr = new XMLHttpRequest();
// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;
// 访问nginx中的代理服务器
xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);
xhr.send();
// server.js
var http = require('http');
var server = http.createServer();
var qs = require('querystring');
server.on('request', function(req, res) {
    var params = qs.parse(req.url.substring(2));
    // 向前台写cookie
    res.writeHead(200, {
        'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'   // HttpOnly:脚本无法读取
    });
    res.write(JSON.stringify(params));
    res.end();
});
server.listen('8080');
console.log('Server is running at port 8080...');
```
## window.name+iframe
window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。
其中a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000

```js
// a.html(http://localhost:3000/b.html)
  <iframe src="http://localhost:4000/c.html" frameborder="0" onload="load()" id="iframe"></iframe>
  <script>
    let first = true
    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
    function load() {
      if(first){
      // 第1次onload(跨域页)成功后，切换到同域代理页面
        let iframe = document.getElementById('iframe');
        iframe.src = 'http://localhost:3000/b.html';
        first = false;
      }else{
      // 第2次onload(同域b.html页)成功后，读取同域window.name中数据
        console.log(iframe.contentWindow.name);
      }
    }
  </script>
b.html为中间代理页，与a.html同域，内容为空。
 // c.html(http://localhost:4000/c.html)
  <script>
    window.name = '我不爱你'  
  </script>
```
总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。


## location.hash+iframe
实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。
同样的，a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000
```js
// a.html
  <iframe src="http://localhost:4000/c.html#iloveyou"></iframe>
  <script>
    window.onhashchange = function () { //检测hash的变化
      console.log(location.hash);
    }
  </script>
 // b.html
  <script>
    window.parent.parent.location.hash = location.hash 
    //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面
  </script>
 // c.html
 console.log(location.hash);
  let iframe = document.createElement('iframe');
  iframe.src = 'http://localhost:3000/b.html#idontloveyou';
  document.body.appendChild(iframe);
```



## document.domain+iframe
document.domain + iframe  强制设置两个页面的document.domain
该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。
只需要给页面添加 document.domain ='test.com' 表示二级域名都相同就可以实现跨域。
实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。
我们看个例子：页面a.zf1.cn:3000/a.html获取页面b.zf1.cn:3000/b.html中a的值
```js
/ a.html
<body>
 helloa
  <iframe src="http://b.zf1.cn:3000/b.html" frameborder="0" onload="load()" id="frame"></iframe>
  <script>
    document.domain = 'zf1.cn'
    function load() {
      console.log(frame.contentWindow.a);
    }
  </script>
</body>
// b.html
<body>
   hellob
   <script>
     document.domain = 'zf1.cn'
     var a = 100;
   </script>
</body>
```



## 总结
- CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案
- JOSNP只支持GET请求，支持老势的浏览器，以及向不支持CORS的浏览器网站请求数据
- 不管是NOde中间件代理还是nginx反向代理，都是通过同源策略对服务器不加限制
- 日常工作中，用得比较多的跨域方案是cors和nginx反向代理



# Promise 对象 then 方法返回的是什么 promise.all()
**概述：Promise是一个对象，可以获取异步操作的消息**
**状态**
Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。
Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即resolved（已定型）。

```js
const p1 = new Promise(function(resolve,reject){
  resolve('success1');
  resolve('success2');
});

const p2 = new Promise(function(){
  resolve('success3');
  reject('reject');

});

const p3 = new Promise(function() {
    resolve('success4');
    reject('reject2')
})

p1.then(function(value){
  console.log(value); // success1
});

p2.then(function(value){
  console.log(value); // success3
});

p3.then(function(err) {
    console.log(err) // reject1
})
```
状态的缺点
1.无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。
2.如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。
3.当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）


**then方法**

then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时候的回调，两个函数只有一个会被调用
在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。
```js
const p = new Promise(function(resolve,reject){
  resolve('success');
});

p.then(function(value){
  console.log(value);
});
console.log('first');
//输出结果
// first
// success
```
通过 .then形式添加的回调函数，不论什么时候，都会被调用。
通过多次调用.then，可以添加多个回调函数，它们会按照插入顺序并且独立运行。
then 方法将返回一个 resolved 或 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。


then方法会返回一个resolved或者rejected状态的promise对象用于链式调用

```js
const p = new Promise(function(resolve,reject){
  resolve(1);
}).then(function(value){ // 第一个then // 1
  console.log(value);
  return value * 2;
}).then(function(value){ // 第二个then // 2
  console.log(value);
}).then(function(value){ // 第三个then // undefined
  console.log(value);
  return Promise.resolve('resolve');
}).then(function(value){ // 第四个then // resolve
  console.log(value);
  return Promise.reject('reject');
}).then(function(value){ // 第五个then //reject:reject
  console.log('resolve:' + value);
}, function(err) {
  console.log('reject:' + err);
});
```

1.简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise。
2.注意总是返回或终止 Promise 链。如下代码所示，创建新 Promise 但忘记返回它时，对应链条被打破，导致 p4 会与 p2 和 p3 同时进行。大多数浏览器中不能终止的 Promise 链里的 rejection，建议后面都跟上 .catch(error => console.log(error));


```js
const p1 = new Promise(function(resolve,reject){
  resolve(1);
}).then(function(result) {
  p2(result).then(newResult => p3(newResult));
}).then(() => p4());
```
**Promise.all多个异步操作，此时我们可以通过promise.all来监听这些异步操作，all的参数是一个数组，每一成代表一个异步操作。**
then方法的回调函数的参数，就是每一次执行异步操作传递的参数，有一个异步操作失败，失败的回调函数就执行了，只有所有的异步操作都执行成功，成功的回调函数才会执行。
在异步操作之后为promise对象定义回调函数，会立即执行，因为此时状态已经改变了。

```js
const p1 = new Promise(function(resolve,reject){
  resolve('success1');
  resolve('success2');
});

const p2 = new Promise(function(){
  resolve('success3');
  reject('reject');

});

const p3 = new Promise(function() {
    resolve('success4');
    reject('reject2')
})


Promise.all([p1,p2,p3]).then(function(value) {
    resolve(value);
    console.log(value);
}, function(err) {
    reject(err);
    console.log(err);
})
```
**then与catch的返回值实践**

then方法是异步执行
当.then()前的方法执行完成后，再执行then()内部的程序，这样就避免了数据没获取到等的问题。
then()方法允许你指定实现承诺的时候要完成的工作

```js
Promise.then(onCompeleted, onRejected);

setTimeout(() => {
    console.log(4)
},0)

new Promise(function(resolve) {
    console.log(1);
    for(var i=0; i<10; i++) {
        i==0 && resolve();
    }
    console.log(2)
}).then(function() {
    console.log(5)
})

function a() {
    console.log(6);
}

a()
console.log(3);
```
1 2 6 3 5 4
承诺必须完成（返回一个值）或者必须被拒绝（返回一个原因）。承诺完成或被拒绝时（无论哪一个先发生），Promise 对象的then方法都会运行。
如果承诺成功完成，则将运行then方法的履行处理程序函数。如果承诺被拒绝，则将运行then方法（或catch方法）的错误处理程序函数。

```js
Promise.resolve(1)
    .then((x) => x+1)
    .then((x) => {throw new Error('error')})
    .catch(() => 1)
    .then((x) => x+1)
    .then((x) => console.log(x))
    .catch(console.log(error))
```
答案是2，如下：
1、创建一个Promise对象，输出1；
2、结果+1，现在的输出为2；
3、输出结果被抛弃，抛出一个error；
4、error被丢弃，返回一个新的value（1）；
5、catch进行异常处理，但catch后程序不停止执行，返回一个信息+1，之后的value(2);
6、value正常输出；
7、value已经正常输出，这一行不会执行
（一）catch为then的语法糖
故then方法与catch方法均会返回一个Promise（即使return为某一个值，或者throw error,或者不返回值）。简单来说，就是分为return 值（无return的情况下即返回undefined，也是返回值），throw error， return Promise
（二）return 值与throw error的情况
        1、return 值的情况：
          返回的Promise会成为Fulfilled状态。
            return的值会作为Promise对象下一个then的回调函数的参数值
          2、throw error的情况
    返回的promise会成为Reject状态，下一步执行catch中的回调函数或者then的第二个回调函数的参数
再次重复这一句话：catch为then的语法糖，它是then(null,rejection)的别名，也就是说catch也是then,它用于捕获错误，它的参数也就是then的第二个参数，所以，假设catch中如果return值的话，新的promise对象也会是接受状态。


# 数组的各种遍历的区别

- for, forEach, for in, for of使用及区别
- filter, map的使用方法使用及区别
- includes，find使用及区别
- some, every使用及区别
- reduce的使用以及常用方法

**for,forEach,for in, for of的区别**

```js
var arr =[1,2,3,4,5]
arr.p='name'

// for

for(let i=0; i<arr.length; i++) {
    console.log(arr[i])
}

// forEach

arr.forEach(item => {
    console.log(item)
})

const arr = [
            {id:1,name:'zhangsan'},
            {id:2,name:'lisi'},
            {id:3,name:'wangwu'}
        ]

arr.forEach( function(item){
            console.log(item.id + '---' +  item.name)
        })

// for in
for(let key in arr) {
    console.log(val)
}

// for of
for(let val in arr) {
    console.log(val)
}

// filter
arr.filter((item) => {
    return item >3
})

// map

arr.map((item) => {
    return item*3;
})

// inclueds
var arr = [1,2,3,4,5];
arr.inclueds(7);//arr数组里有7吗？没有返回false

// indexOf
arr.indexOf(7) -1
arr.indexOf(1) 0

// find
var arr = [1,2,3,4];
var result = arr.find(function(item,index){
    return item.toString().indexOf('5')>-1
})
// result:undefined
var result2 = arr.find(function(item,index){
    return item.toString().indexOf('2')>-1
})
//result2:2

```
**for:for循环不到数组的私有属性，for循环可以使用continue|break|return终止结束循环，for属于编程时写法**
**forEach循环不到数组的私有属性，没有返回值，continue|return|break不起作用，forEach属于函数声明式写法不关系具体的实现**
**for in遍历可枚举的对象，可以获得对象的属性和值，可以遍历对象的私有属性，key是string类型，可以使用return|break|continue，循环不一定按照数组索引值来循环**
**for of不可以遍历数组的私有属性的值,val的值就是arr各项的值，可以使用return|break|continue中止循环**

**map是对数组的每一项遍历操作，返回一个新的数组**
**filter过滤后的数组，不操作原数组**

**includes返回的是Boolean**
**indexOf返回的是出现次数的下标，没有返回-1**
**find查找数组中的值**
**some数组是否有这一项，找到true后停止循环，返回true，找不到返回false**
**every：找到false停止循环返回false，找不到返回true**

```js
 var arr = [1,2,3,4,5];
    var someArr =  arr.some(function(item){
        return item>3
    });
    //someArr : true
    var everyArr = arr.every(function(item){
        return item<0
    });
    //everyArr:false
```
**reduce不改变原数组值，可以实现叠加器，累加，遍历数组,数组扁平化**
```js
var arr =[1,2,3,4,5]
arr.reduce(function(prev, next, index, item) {
    console.log(arguments)
})
```
# canvas 和 svg 的区别

**canvas和svg都运行在浏览器中创建图形，本质上是不同的，图形**

**canvas**
- 使用javasript来绘制2d图形
- 逐像素进行渲染
- 位置发生改变，重新绘制

**SVG**
- 一种使用XML描述的2D图形的语言
- SVG基于XML意味着，SVG DOM中每个元素都是可用的，可以为某个元素附加JavaScript事件处理器
- 在SVG中，每个被绘制的图形都被视为对象，如果SVG对象的属性发生变化，浏览器能够自动重现图形

**比较**

Canvas
依赖分辨率
不支持事件处理器
弱的文本渲染能力
能够以 .png 或 .jpg 格式保存结果图像
最适合图像密集型的游戏，其中的许多对象会被频繁重绘

canvas依赖分辨率吧，不支持事件处理器，弱的文本渲染能力，游戏

SVG
不依赖分辨率
支持事件处理器
最适合带有大型渲染区域的应用程序（比如谷歌地图）
复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
不适合游戏应用

svg不依赖分辨率，支持事件处理器，大型渲染区域的应用程序，复杂度高会减慢渲染速度，不适合游戏应用，不适合频繁重绘


# 可视化的理解：使算法数据结构用图形化来表现 图形化界面

前端可视化，echarts highcharts
可视化相对来说是一个相对独立的理论的理论学科，同时也可以说是一个跨学科的体系，不止是前端，其实我们所使用的桌面系统，GUI 都属于可视化的一部分，包括算法，数据分析其实都是依靠图形化界面，也就是可视化的。这样来看可视化是非常庞大的。
所以前端可视化只是可视化方向的一个技术分支，我觉得主要是因为环境，加上浏览器的兼容，以及有 canvas 和对 webgl 的友好支持，基本涵盖了 2D 和 3D 图形化成像。


着可视化方向重点了解一下 canvas 和 webgl，canvas 相对还好，webgl 不建议一开始直接使用，可以看看 three.js，包括其中的例子，都值得看看。国内外也有比较好的可视化库，比如 echars，D3，highchart 等。
其实看这些优秀开源作品除了会用外，其实应该去看看为什么这个设计，有什么业务逻辑包含在里面，别人做可视化为什么要用这个，对用户友好还是思维习惯，这也是我在思考的和接着去学习的。所以除了技术本身，可视化还应该了解的知识还有设计，交互，以及产品业务思维。逐渐深入可能还会接触到图形学和数学知识等。
我觉得以上知识，短时间内一个人不太容易搞定，可以慢慢培养，一个成体系的可视化作品肯定需要不同的人协作的，多思考，或者先加强自己参与的部分，扩展边界，有自己的想法。
总结一下：前端相关知识，交互 & 设计，图形学，数学，产品思维等。


# this 指针
谁最后调用，this就指向谁

**全局上下文**
非严格模式和严格模式中this都是指向顶层对象，浏览器中是window
```js
this === window // true
'use strict'
this === window;
this.name = '若川';
console.log(this.name); // 若川
```

**函数上下文**
函数在执行的过程中会提升到顶层，普通函数执行的时候 this指向window,全局变量挂在在顶层对象上，但是let没有给顶层对象window添加属性

```js
// 非严格模式
var name = 'window';
var doSth = function(){
    console.log(this.name);
}
doSth(); // 'window'

// 非严格模式
let name2 = 'window2';
let doSth2 = function(){
    console.log(this === window);
    console.log(this.name2);
}
doSth2() // true, undefined


// 严格模式
'use strict'
var name = 'window';
var doSth = function(){
    console.log(typeof this === 'undefined');
    console.log(this.name);
}
doSth(); // true，// 报错，因为this是undefined

```
**对象中的函数（方法）调用模式**
当作函数的对象方法调用的时候指向该对象

```js
var name = 'window';
var doSth = function(){
    console.log(this.name);
}
var student = {
    name: '若川',
    doSth: doSth,
    other: {
        name: 'other',
        doSth: doSth,
    }
}
student.doSth(); // '若川'
student.other.doSth(); // 'other'
// 用call类比则为：
student.doSth.call(student);
// 用call类比则为：
student.other.doSth.call(other);
```


**new构造函数调用模式**
this指向新生成的实例
```js
function Student(name){
    this.name = name;
    console.log(this); // {name: '若川'}
    // 相当于返回了
    // return this;
}
var result = new Student('若川');
```

**使用new操作符调用函数，会自动执行以下步骤**
- 创建一个全新的空对象obj
- 这个对象会被执行[[prototype]] 就是__proto__连接
- 生成的新的对象会绑定到函数调用的this
- 通过new创建的对象最终被[[Prototype]]链接到这个函数的prototype对象上。
- 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。

由此可以知道：new操作符调用时，this指向生成的新对象。 特别提醒一下，new调用时的返回值，如果没有显式返回对象或者函数，才是返回生成的新对象。

```js
function Student(name){
    this.name = name;
    // return function f(){};
    // return {};
}
var result = new Student('若川');
console.log(result); {name: '若川'}
// 如果返回函数f，则result是函数f，如果是对象{}，则result是对象{}
```

**箭头函数调用模式**
普通函数和箭头函数的区别：
- 箭头函数没有this，继承距离箭头函数最近的this 上下文的this
- 箭头函数没有自己的this super arguments和 new.target绑定
- 不能使用new来调用
- 没有原型对象
- 不可以改变this指向 不能使用call apply bind
- 形参名不能重复
- 不能使用generator
箭头函数中没有this绑定，必须通过查找作用域链来决定其值。 如果箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this，否则this的值则被设置为全局对象。 比如：
```js
var name = 'window';
var student = {
    name: '若川',
    doSth: function(){
        // var self = this;
        var arrowDoSth = () => {
            // console.log(self.name);
            console.log(this.name);
        }
        arrowDoSth();
    },
    arrowDoSth2: () => {
        console.log(this.name);
    }
}
student.doSth(); // '若川'
student.arrowDoSth2(); // 'window'
```
其实就是相当于箭头函数外的this是缓存的该箭头函数上层的普通函数的this。如果没有普通函数，则是全局对象（浏览器中则是window）。
也就是说无法通过call、apply、bind绑定箭头函数的this(它自身没有this)。而call、apply、bind可以绑定缓存箭头函数上层的普通函数的this。

```js
var student = {
    name: '若川',
    doSth: function(){
        console.log(this.name);
        return () => {
            console.log('arrowFn:', this.name);
        }
    }
}
var person = {
    name: 'person',
}
student.doSth().call(person); // '若川'  'arrowFn:' '若川'
student.doSth.call(person)(); // 'person' 'arrowFn:' 'person'
```


**call，apply，bind**
使用myFun.call()或myFun.apply()方法调用函数时，执行的是隐式调用。
JS中的函数是第一类对象，这意味着函数就是对象，对象的类型为Function。从函数对象的方法列表中，.call()和.apply()用于调用具有可配置上下文的函数。


方法 .call(thisArg[, arg1[, arg2[, ...]]])将接受的第一个参数thisArg作为调用时的上下文，arg1, arg2, ...这些则作为参数传入被调用的函数。


方法.apply(thisArg, [args])将接受的第一个参数thisArg作为调用时的上下文，并且接受另一个类似数组的对象[arg1, arg2, ...]作为被调用函数的参数传入。

```js

function increment(number) {
  return ++number;  
}
increment.call(undefined, 10);    // => 11
increment.apply(undefined, [10]); // => 11
```
increment.call()和increment.apply()都用参数10调用了这个自增函数。
两者的区别是.call()接受一组参数，例如myFunction.call(thisValue, 'value1', 'value2')。而.apply()接受的一组参数必须是一个类似数组的对象，例如myFunction.apply(thisValue, ['value1', 'value2'])。

call(undefined,10)
apply(undefined,[10])

很明显，在隐式调用中，this作为第一个参数传递给.call()或.apply()。

```js
var rabbit = { name: 'White Rabbit' };
function concatName(string) {
  console.log(this === rabbit); // => true
  return string + this.name;
}
concatName.call(rabbit, 'Hello ');  // => 'Hello White Rabbit'
concatName.apply(rabbit, ['Bye ']); // => 'Bye White Rabbit'
```
绑定函数是与对象连接的函数。通常使用.bind()方法从原始函数创建。原始函数和绑定函数共享相同的代码和作用域，但执行时上下文不同。
方法 myFunc.bind(thisArg[, arg1[, arg2[, ...]]])接受第一个参数thisArg作为绑定函数执行时的上下文，并且它接受一组可选的参数 arg1, arg2, ...作为被调用函数的参数。它返回一个绑定了thisArg的新函数。


```js
function getThis() {
  'use strict';
  return this;
}
const one = getThis.bind(1);
// 绑定函数调用
one(); // => 1
// 使用带有.apply()和.call()的绑定函数
one.call(2);  // => 1
one.apply(2); // => 1
// 再次绑定
one.bind(2)(); // => 1
// 以构造函数的形式调用绑定函数
new one(); // => Object
```


**DOM事件处理函数调用**

addEventerListener、attachEvent、onclick

```js
<button class="button">onclick</button>
<ul class="list">
    <li>1</li>
    <li>2</li>
    <li>3</li>
</ul>
<script>
    var button = document.querySelector('button');
    button.onclick = function(ev){
        console.log(this);
        console.log(this === ev.currentTarget); // true
    }
    var list = document.querySelector('.list');
    list.addEventListener('click', function(ev){
        console.log(this === list); // true
        console.log(this === ev.currentTarget); // true
        console.log(this);
        console.log(ev.target);
    }, false);
</script>
```
onclick和addEventerListener是指向绑定事件的元素。
一些浏览器，比如IE6~IE8下使用attachEvent，this指向是window。
顺便提下：面试官也经常考察ev.currentTarget和ev.target的区别。
ev.currentTarget是绑定事件的元素，而ev.target是当前触发事件的元素。比如这里的分别是ul和li。
但也可能点击的是ul，这时ev.currentTarget和ev.target就相等了。



**内联事件处理函数调用**
<button class="btn1" onclick="console.log(this === document.querySelector('.btn1'))">点我呀</button>
<button onclick="console.log((function(){return this})());">再点我呀</button>

第一个是button本身，所以是true，第二个是window。这里跟严格模式没有关系。
当然我们现在不会这样用了，但有时不小心写成了这样，也需要了解。
其实this的使用场景还有挺多，比如对象object中的getter、setter的this，new Function()、eval。
但掌握以上几种，去分析其他的，就自然迎刃而解了。
使用比较多的还是普通函数调用、对象的函数调用、new调用、call、apply、bind调用、箭头函数调用。
那么他们的优先级是怎样的呢。

**优先级**
而箭头函数的this是上层普通函数的this或者是全局对象（浏览器中是window），所以排除，不算优先级。
```js
var name = 'window';
var person = {
    name: 'person',
}
var doSth = function(){
    console.log(this.name);
    return function(){
        console.log('return:', this.name);
    }
}
var Student = {
    name: '若川',
    doSth: doSth,
}
// 普通函数调用
doSth(); // window
// 对象上的函数调用
Student.doSth(); // '若川'
// call、apply 调用
Student.doSth.call(person); // 'person'
new Student.doSth.call(person);
```
试想一下，如果是Student.doSth.call(person)先执行的情况下，那new执行一个函数。是没有问题的。
然而事实上，这代码是报错的。运算符优先级是new比点号低，所以是执行new (Student.doSth.call)(person)
而Function.prototype.call，虽然是一个函数（apply、bind也是函数），跟箭头函数一样，不能用new调用。所以报错了。
```js
Uncaught TypeError: Student.doSth.call is not a constructor
```

这是因为函数内部有两个不同的方法：[[Call]]和[[Constructor]]。
当使用普通函数调用时，[[Call]]会被执行。当使用构造函数调用时，[[Constructor]]会被执行。call、apply、bind和箭头函数内部没有[[Constructor]]方法。
从上面的例子可以看出普通函数调用优先级最低，其次是对象上的函数。
call（apply、bind）调用方式和new调用方式的优先级，在《你不知道的JavaScript》是对比bind和new，引用了mdn的bind的ployfill实现，new调用时bind之后的函数，会忽略bind绑定的第一个参数，(mdn的实现其实还有一些问题，感兴趣的读者，可以看我之前的文章：面试官问：能否模拟实现JS的bind方法)，说明new的调用的优先级最高。
所以它们的优先级是new 调用 > call、apply、bind 调用 > 对象上的函数调用 > 普通函数调用。

**new>call apply bind>对象上的函数调用>普通函数调用**

如果要判断一个运行中函数的 this 绑定， 就需要找到这个函数的直接调用位置。 找到之后
就可以顺序应用下面这四条规则来判断 this 的绑定对象。

new 调用：绑定到新创建的对象，注意：显示return函数或对象，返回值不是新创建的对象，而是显式返回的函数或对象。
call 或者 apply（ 或者 bind） 调用：严格模式下，绑定到指定的第一个参数。非严格模式下，null和undefined，指向全局对象（浏览器中是window），其余值指向被new Object()包装的对象。
对象上的函数调用：绑定到那个对象。
普通函数调用： 在严格模式下绑定到 undefined，否则绑定到全局对象。

ES6 中的箭头函数：不会使用上文的四条标准的绑定规则， 而是根据当前的词法作用域来决定this， 具体来说， 箭头函数会继承外层函数，调用的 this 绑定（ 无论 this 绑定到什么），没有外层函数，则是绑定到全局对象（浏览器中是window）。 这其实和 ES6 之前代码中的 self = this 机制一样。
DOM事件函数：一般指向绑定事件的DOM元素，但有些情况绑定到全局对象（比如IE6~IE8的attachEvent）。
一定要注意，有些调用可能在无意中使用普通函数绑定规则。 如果想“ 更安全” 地忽略 this 绑
定， 你可以使用一个对象， 比如ø = Object.create(null)， 以保护全局对象。
面试官考察this指向就可以考察new、call、apply、bind，箭头函数等用法。从而扩展到作用域、闭包、原型链、继承、严格模式等。这就是面试官乐此不疲的原因。
读者发现有不妥或可改善之处，欢迎指出。另外觉得写得不错，可以点个赞，也是对笔者的一种支持。

# 原生 ajax 请求实现
是一种用来改善用户体验的技术，其本质是利用**浏览器内置的特殊对象（XMLHttpRequest，也就是Ajax对象）**，向服务器发送异步请求，服务器返回部分数据（通常不会是整个页面），浏览器利用这些数据对页面做部分更新，整个访问服务器的过程没有存在月面的刷新，不会打断用户的操作
异步请求：发送请求的同时，流浪其不会销毁当前页面，用户仍然可以对当前页面做其他操作

兼容性问题：


ie使用的是ActiveXObject


其他浏览器是XMLHttpRequest
这里就有兼容性问题，对于不同的浏览器有不同的解决办法，底层的解决办法是：
```js
function  getxhr() {
var xhr = null;
if(window.XMLHttpRequest)
{
xhr = new XMLHttpRequest();
}
else
{
xhr = new ActiveXObject("Microsoft.XMLHttp");
}
return xhr;
}
```

```js
// 创建一个异步请求对象
let xhr = new XMLHttpRequest();
// 设置发送请求的方法域名，是否发送异步请求，false的时候，发送请求，浏览器会锁定当前页面，用户不能做其他操作
xhr.open('GET','http://localhost:8080',true)
// 设置状态变化的函数
xhr.onreadyStatechange= function() {
    if(xhr.readyState===4 && xhr.status===200) {
        xhr.responseTxt()
    }
}
// 发送请求
xhr.send()
// 请求失败的时候
xhr.error=function() {
    console.log(err)
}

function ajax(url,method) {
    var xhr=null
    if(window.XMLHttpRequest) {
         xhr = new XMLHttpRequest()
    } else {
        // ie浏览器
        xhr = new ActiveObject("Microsoft.XMLHttp")
    }
    xhr.open(method,url,true)
    return new Promise((resolve, reject) => {
        xhr.onreadychange= function() {
            if(xhr.readyState===4 && xhr.status===200) {
                resolve(xhr.responseTxt)
            }else {
                reject(error);
            }
        }
    })
    xhr.send();
    xhr.onerror= function() {
        console.log('请求失败')
    }
}
var url ='http://www.baidu.com'
var method='GET'
ajax({
    url:'http://www.baidu.com',
    method:true
}).then((data) => {
    console.log(data)
})
```
ajax对象的属性

onReadyStateChange
用来绑定一个事件处理函数，用来处理readyStateChange事件
当ajax对象中的readyState属性值发生从0到1的改变的时候，就会产生readystatechange事件
readyState
有五个值（0，1，2，3，4）
表示ajax对象和服务器通信的状态
如果值为4的时候，表示ajax对象已经获取了服务器返回的所有数据
这个事件事件处理函数就可以从对象中读取数据
responseText
返回的对象中的文本数据
responseXML 
返回的对象中的xml数据
status
获得状态码
500服务器出错
200服务器正常
404请求路径无法找到
302重定向

# event loop
**进程和线程**

进程：是CPU资源分配的最小单位
线程：是CPU调度的最小单位

一个进程由多个线程组成，一个进程有独立分配到内存空间，线程是共享进程的内存空间，多个进程之间相互独立

**多进程和多线程**
- 多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。 多进程之间互不干扰相互独立
- 多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。

**打开浏览器一个Tab页，创建了一个进程，一个进程有多个线程，旋绕线程，js引擎线程，主线程，HTTP请求线程，异步线程等等**

**浏览器内核是通过获取页面内容，信息计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。**
浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：
- GUI 渲染线程
    主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。
当界面需要重绘或者由于某种操作引发回流时，将执行该线程。
该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。
- JavaScript引擎线程
  - 该线程当然是主要负责处理 JavaScript脚本，执行代码。
  - 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。
  - 当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。
- 定时触发器线程
  - 负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。
  - 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。
- 事件触发线程
  - 主要负责将准备好的事件交给 JS引擎线程执行
  - 比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。
- 异步http请求线程
  - 负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。
  - 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线���会将回调函数加入到任务队列的尾部，等待JS引擎线程执行

# Event Loop
i
## Macro-Task 与Micro-Task 宏任务和微任务

浏览器事件循环中的异步队列有两种：macro（宏任务队列）和micro（微任务队列）。宏任务队列可以有多个，微任务队列只有一个

macro-task：setTimeout,setInterval,script(整体代码),I/O操作，UI渲染等

micro-task：比如new Promise().then()回调，MutationObserve(html5新特性)，promise，nexttick

**Event loop过程解析**

- 一开始执行栈空,我们可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。
- 全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。

- 上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。

- 执行渲染操作，更新界面
- 检查是否存在 Web worker 任务，如果有，则对其进行处理
- 上述过程循环往复，直到两个队列都清空

**当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。**

```js
Promise.resolve().then(()=>{
  console.log('Promise1')  
  setTimeout(()=>{
    console.log('setTimeout2')
  },0)
})
setTimeout(()=>{
  console.log('setTimeout1')
  Promise.resolve().then(()=>{
    console.log('Promise2')    
  })
},0)
```

Promise1 setTimeout1 Promise2 setTimeout1

- 一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出Promise1，同时会生成一个宏任务 setTimeout2
- 然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1
- 在执行宏任务setTimeout1时会生成微任务Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2
- 清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2

## Node 中的 Event Loop
Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现（下文会详细介绍）。

Node.js的运行机制如下:

- v8引擎解析JavaScript脚本
- 解析后的代码 调用node api
- libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。
- V8引擎再将结果返回给用户。

**六个阶段**
其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。

从上图中，大致看出node中的事件循环的顺序：
外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段（按照该顺序反复运行）...

- timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调
- I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调
- idle, prepare 阶段：仅node内部使用
- poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里
- check 阶段：执行 setImmediate() 的回调
- close callbacks 阶段：执行 socket 的 close 事件回调

注意：上面六个阶段都不包括 process.nextTick()(下文会介绍)
接下去我们详细介绍timers、poll、check这3个阶段，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。


(1) timer
timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。

(2) poll
poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情
1.回到 timer 阶段执行回调
2.执行 I/O 回调
2.执行 I/O 回调
并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情

如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制
如果 poll 队列为空时，会有两件事发生

如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去



当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。

(3) check阶段
setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。 我们先来看个例子:

```js
console.log('start')
setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(function() {
    console.log('promise1')
  })
}, 0)
setTimeout(() => {
  console.log('timer2')
  Promise.resolve().then(function() {
    console.log('promise2')
  })
}, 0)
Promise.resolve().then(function() {
  console.log('promise3')
})
console.log('end')
//start=>end=>promise3=>timer1=>timer2=>promise1=>promise2
```
一开始执行栈的同步任务（这属于宏任务）执行完毕后（依次打印出start end，并将2个timer依次放入timer队列）,会先去执行微任务（这点跟浏览器端的一样），所以打印出promise3
然后进入timers阶段，执行timer1的回调函数，打印timer1，并将promise.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；这点跟浏览器端相差比较大，timers阶段有几个setTimeout/setInterval都会依次执行，并不像浏览器端，每执行一个宏任务后就去执行一个微任务（关于Node与浏览器的 Event Loop 差异，下文还会详细介绍）

3.Micro-Task 与 Macro-Task
Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。

常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。
常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。

4.注意点
(1) setTimeout 和 setImmediate
二者非常相似，区别主要在于调用时机不同。

setImmediate 设计在poll阶段完成时执行，即check阶段；
setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行


```js
setTimeout(function timeout () {
  console.log('timeout');
},0);
setImmediate(function immediate () {
  console.log('immediate');
});
```
timeout immediate

对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。
首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的
进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调
如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了

但当二者在异步i/o callback内部调用时，总是先执行setImmediate，再执行setTimeout

immediate在poll轮询完执行 timeout在poll空闲的时候 timer执行

```js
const fs = require('fs')
fs.readFile(__filename, () => {
    setTimeout(() => {
        console.log('timeout');
    }, 0)
    setImmediate(() => {
        console.log('immediate')
    })
})
// immediate
// timeout
```
在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。
(2) process.nextTick
这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。
```js
setTimeout(() => {
 console.log('timer1')
 Promise.resolve().then(function() {
   console.log('promise1')
 })
}, 0)
process.nextTick(() => {
 console.log('nextTick')
 process.nextTick(() => {
   console.log('nextTick')
   process.nextTick(() => {
     console.log('nextTick')
     process.nextTick(() => {
       console.log('nextTick')
     })
   })
 })
})
// nextTick=>nextTick=>nextTick=>nextTick=>timer1=>promise1
```
**Node与浏览器的 Event Loop 差异**
浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。 
```js
setTimeout(()=>{
    console.log('timer1')
    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)
setTimeout(()=>{
    console.log('timer2')
    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)
```
**浏览器端运行结果：timer1=>promise1=>timer2=>promise2**

**Node端运行结果分两种情况：**

如果是node11版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为timer1=>promise1=>timer2=>promise2
如果是node10及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中。

如果是第二个定时器还未在完成队列中，最后的结果为timer1=>promise1=>timer2=>promise2
如果是第二个定时器已经在完成队列中，则最后的结果为timer1=>timer2=>promise1=>promise2(下文过程解释基于这种情况下)



1.全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行；
2.首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；
3.至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2

**总结**
浏览器和Node 环境下，microtask 任务队列的执行时机不同
Node端，microtask 在事件循环的各个阶段之间执行
浏览器端，microtask 在事件循环的 macrotask 执行完之后执行

**浏览器的event loop 微任务总是在宏任务之后执行，而node端微任务总是在事件循环的各个阶段执行**

# http2.0 和 http1.1 对比
- 二进制
- 头部压缩
- 多路复用
- 设置请求优先级
- 服务器推送


# http 缓存（强缓存和协商缓存）
http Cache
本地磁盘
**强缓存（本地缓存）协商缓存（弱缓存**

# react 生命周期

# 组件构造函数中 super 作用，super 可以不写吗
不写就没有this 不能使用state

**super是允许访问父类的方法，如果子组件需要使用父组件的props必须在constructor里使用super，这样才可以使用this.props**


**可以不写constructor但是写了constructor就必须写上super，就可以在组建的全局中使用this关键字**

**在调用super之前无法使用this关键字React 里面就是指代 React.Component 的构造函数**

**不管子类子组件有没有constructor在实例化的过程中会生成**


# babel 原理 class 是转换成什么

# 移动端适配方案 rem 的换算

# 二叉树的深度（递归、非递归）

# 数组的前置和与后置和相等的子数组的个数。

一个数组 x[]，数组每一个元素都大于 0，称 x[0] + …+ x[i]为前置和，而 x[j] + … + x[n-1]为后置和，写一个程序，求 x 有多少相同的前置和后置和。 示例 [1, 2, 5, 1, 8, 9, 7, 1] 前置[1,2,5] = 后置[1,7] ，即找到类似这样的子数组的个数。

# 讲一下 react hook

# 讲一下 redux 的原理

# 组件通信的几种方法

# TypeScript 有了解吗，稍微讲一下

# 讲一下数组的方法，哪些修改原数组

# 如何判断一个对象是数组

# 原型链

# SASS 与 CSS 区别，CSS 属性如何兼容不同浏览器

# 讲一下请求头和响应头

# OSI 七层模型

# 详细介绍物理层到数据链路层的工作流程

# ipv4 和 ipv6 的区别
**ip地址协议的版本号，都属于互联网协议**
**ipv6地址空间更大,2^128-1而ipv4的是2^32-1**
**ipv6的路由表更小可使路由器能在路由表中，用一条记录表示一片子网。大大减小了路由器中路由表的长度，提高了路由器转发数据包的速度。**
**ipv6的组播支持以及对流的支持增强，网络更快**
**IPv6加入了对自动配置的支持。**
**IPv6具有更高的安全性。在使用IPv6网络中，用户可以对网络层的数据进行加密并对IP报文进行校验，这极大地增强了网络安全。**
**IPv6允许协议扩充。**
**IPv6使用新的头部格式，简化和加速了路由选择过程，因为大多数的选项不需要由路由选择。**


**总而言之，ipv6地址空间大，路由表更小提高路由器转发数据包速度，支持流，网络传输快，增加了网络安全**

# https 和 http
- https协议需要到CA（Certificate Authority证书颁发机构）申请证书，https成本高
- http是超文本传输协议，是明文传输，https是具有安全性的ssl加密传输 基于http
- http和https是使用完全不一样的连接方式，端口号也不一样，前者是80，后者是443
- http协议是无状态的协议，https是由http+sssl构建的可以加密传输，身份认证的网络协议，比http安全可靠。http是无状态无连接的协议，无状态是指数据包的发送传输接收都是相互独立的，无连接的意思就是双方不能持久的维持对方的任何信息

# SSL，CA 正式，加密（对称，非对称）

# WEB 安全 （CSRF，XSS，SQL 注入）

# 北京用户打开页面白屏，其他地区打开显示正常，如何对问题进行排查
1、先确保网络连接通畅。
2、查看网络url地址是否输入有误。
3、打开控制台查看报错信息。
4、查看接口访问是否有请求。
5、查看路由是否有path或者name的错误，导致加载了不存在的页面。
一般这几个步骤走完，基本能够定位问题了
# 对于 100 条产品线（外卖、电影、生鲜等等），如果页面的 cookie 满了，如何解决

# 斐波那契数列，求第 20 项

```js
function Fobonaci(n) {
    if(n<=2)  {
        return 1;
    }else {
        return Fobonaci(n-1)+Fobonaci(n-2)
    }
}
```
**缓存**
```js
function fibonaci() {
    // 保存我们存储的结果
    var f=[0,1];
    var fib = function(n) {
        var res = f[n];
        if(typeof res !== 'number') {
            res = fib(n-1)+fib(n-2);
            f[n]= res;
        }
        return res;
    }
    return fib;
}();

for(var i=0; i<=10; i++) {
    var fibona=fibonaci(i);
    console.log(fibona);
}
```

**闭包**
```js
var fibonacci = function() {
    // fn数组存储我们的结果
    var fn =[0,1]
    return function fibo(n) {
        var res = fn[n];
        // 判断res是否是数
        if(typeof res !== 'number') {
            res = fibo(n-1)+fibo(n-2);
            fn[n]=result;
        }
    }
}();

for(var i=0; i<10; i++) {
    var fb = fibonacci(i);
    console.log(fb);
}
```

# count 函数

```js
// 写一个 count 函数
count(); // 0
count(); // 1
count(); // 2
//...
```
```js
function count(n) {
    if(n<=0) {
        return 0;
    }else {
        return n
    }
}


```
# Vue 是什么框架 好处

# Vue 如何打包 JS

# template 和 script 如何结合

# webComponent

# vue 的双向绑定

# 发布订阅模式和观察者模式的区别 观察者模式怎么监听到变化去操作的

# 消息中间件

# 详细介绍一下多路复用

TCP 是和域名绑定的吗？一个标签开了两个页面，TCP 连接能否复用？
一台服务器能够承受多少 TCP 的连接

# 多路复用对性能优化有什么改变 之前把所有依赖包压成一个文件，这个在 HTTP2.0 是否可以

# JSONP 只能 GET，为什么 CORS 跨域原理

# 首屏时间优化 如何收集用户的首屏时间 首屏时间是哪一个时间节点

# 浏览器渲染过程 JS 在其中的扮演角色

# 框架打包使用 JS 进行渲染

# onload 时间节点的收集

onload事件在资源被加载完成后会被触发script标签的onload事件都是在外部js文件被加载完成并执行完成后才被触发的。

# axios 兼容性 底层怎么封装的

# 浏览器和 Node 端发送请求有什么差别

# 算法题：一个正整数开根号，精确到小数点后 6 位
```js
function sqrt(n) {
    return Math.sqrt(n).toFiexed(6)
}
```
时间复杂度  O(n*sqrt(n))
复杂度

# 数据库有几张表，然后问了个需求如何写查询语句

SQL 注入，防范
express 中间件
深入 body-parser 的

# get 和 post 区别

# HTTP Header 的内容

缓存
哪些是请求头，哪些是响应头
跨域
哪些是请求头，哪些是响应头

# 判断一个对象是不是数组

Object 的 toSting 和 Array.toString 有什么区别
typeof 可不可以
```js
var obj={name:'www'}

var arr =[1,2,3]

obj.toString()
"[object Object]"
arr.toString()
"1,2,3"
```

对象的toString会打印出[Object,Object]
数组的toString()转化成字符串
# Object 原型上面还有什么方法

```js
"toString" in Object; //true
for (let a in { a: 1 }) console.log(a); //a
```

两者为什么下面没有打印原型上的内容

# for ... of 循环，为什么不能是对象 for...in 只能遍历对象自己和原型链上可枚举的属性

for...of 不能遍历对象的私有属性 遍历类数组

for...in遍历可枚举的属性对象



# 如何让 es6 的语法跑到所有浏览器上

# absolute 和 fixed 区别
   1、fixed--固定定位，参照位置是浏览器窗口的左上角。
　　2、absolute--绝对定位，参照位置是离当前元素最近的定位方式为fixed、absolute、relative的祖先元素的左上角。

不滚动没有滚动条的情况下没有区别，有滚动条的情况下absolute会随滚动条变化 而fixed不会


fixed用域遮罩层
# 移动端适配

rem
vw 会不会有兼容性问题

# elementUI 如何做到响应式布局

# 可能是让我说弹性布局吧。。。 flex:1

flex:0 1 auto1

# 二叉树，找到两个节点的第一个父节点

# 写一个 f2，以 f1 为参数，f2(f1)能够将 f1 的第一个参数变成数组，第二个参数不变

var f1 = (x, y)=>{ console.log(x, y)}
写出来了，又问如果 y 不是一个值，可能为空值，也可能为很多个值。

# 去重

[ { id : 1, w : 2}, { id: 2, w : 4 }, { id: 2, w:5 }]按照 id 去重，保留 w 最大值，而且不能改变相对顺序。 用了很笨的方法，面试官提示可以用字典。

```js
function unique(arr) {
    var res =[];
    var obj ={}
    for(var i=0; i<arr.length;i++) {
        // 如果键对应的值，为真，意味对象的键有重复的值
        if(!obj[arr[i]]) {
            // 将预算作为对象的键，默认为true
            obj[arr[i]]=true;
            res.push(arr[i]);
        }
    }
    return result;
}
```

# 求 1， 2， ，3 ，，，，n 如果用二进制表示，问共有多少位 1. 用了 dp

# 将一个数组分成 sum 相同的两部分

# 滚动动画怎么实现

监听滚轮位置，动画盒子与滚轮盒子相互配合，动画盒子固定定位展示动画，滚轮盒子撑起高度与滚动距离，将滚轮滚动距离配合动画长度，转成百分比控制进度

# 怎么懒加载？

src 置空，添加 data-src 或者用 image 对象配合 canvas 画图

# 达到的效果？（加载时间减少 2 秒左右）

怎么看的加载时间（本地看，lighthouse）

# Lighthouse 有哪些优化的建议

缩减 JS 的关键路径、白屏时间、首次渲染时间、CPU 空闲时间，转换资源格式，区分首屏资源与非首屏资源

# CSS 动画与 Canvas 动画的区分，选择的原因（加载图片量的大小）

替换图片的 src 也可以实现，为什么要用 canvas 呢？（控制图片加载时间，可以不用等图片替换后再请求资源）

# sort（）的内部实现 js里的sort时间复杂度

# push（）返回值是啥：数组长度

# 后端传一堆数据过来不会卡顿

# 优化大文件上传，怎么设计交互，提高用户体验性（上传时间很长）

# 节流？防抖？

# 鉴权？前后端同时进行，前端控制显示，后端中间件鉴权

# （回文数，斐波那契数列，两数交换）

# 自己的项目中 password 是如何储存的，知不知道 salt

node bcrypt 单向加密成 hash 值储存进数据库，用的 saltround 每次登陆验证加密之后的 hash 与数据库中 hash 是否相等

# jwt token，储存在 session storage 里，为什么不用 cookie，cookie 有哪些优势

# 宏任务执行栈

```js
for (var i = 1; i <= 3; i++) {
  settimeout(() => {
    console.log(i);
  }, 0);
}
```

# 如何创建 1000 个<div></div>并添加进 document.body

避免一次添加一个会有回流问题，先创建 documentFragment，做循环添加完了最后 append 进 body 里。
除了回流还有什么性能问题如果一次添加一个进 body 里

# ['1a', '3b', '1c', '2a', '7b', '2a']这样一个由数字和字母构成的数组，求出现最多次字母的前系数和，例如：a 出现了三次，最多，输出 1+2+2=5

这里先构建 obj={}, key 为字母，value 为出现次数，再操作，结果不是最优解。出了结果，在考官指引下优化，考官不会提太多，靠自己，能最优一定最优

# {bill:500, sam:480, roark:501}为输入，请按 value 的大小降序输出 key 值，例如[ 'roark', 'bill', 'sam' ]

```js

function sortting(obj) {          
    let resultAry = []          
    for (let i in obj) {          
        var temp = {}          
        temp[i] = obj[i]          
        temp.value = obj[i]          
        resultAry.push(temp)          
    }           
    resultAry.sort((a,b)=> b.value-a.value)          
    let result = []          
    for (let i = 0; i<resultAry.length; i++) {          
        delete resultAry[i].value           
        result = result.concat(Object.keys(resultAry[i]))          
    }          
    console.log(result)          
}           
let test = {bill:500, sam:480, roark:501}          
sortting(test)
```
# 单页面与多页面的区别
# js的垃圾回收机制
# VUE的生命周期
# created之后可以拿数据，那操作数据的时候会发生什么呢？（给他讲了VUE的响应式原理）
# 块级元素和行内元素区别？怎么设置？ 
# CSS
CSS选择器的权重知道吗？（给他说了style>id>class>标签） 你说的这个比较简单，那情况复杂起来怎么处理呢，比如说这个元素的CSS很复杂，但是我这时候就是想给他加一个颜色属性怎么办？（！important或者计算权重） 
# Webpack用过哪些loader和plugiN,打包的具体原理
# js对象一定能访问父节点的属性么？回答如果设置了[get]就可以。又问[get]
# 对象属性的属性
# 事件监听。然后又追问捕获和冒泡机制的好处
# vuex干什么的，设计模式？三个字概括一下这个思想 
# TCP与UDP的区别，应用场景
# position定位
# 动画有哪几种？实现过程？
# 如果一个请求，接收不到界面，该怎么查询问题？可能原因是什么？
# 进程与线程
# CSS盒子模型，由哪几部分组成？高度怎么设置？只能通过boder设置吗？
# 算法题：实现将一个数组分配到两棵树中，使得两棵树中的元素和的差值最小
# 写一个冒泡排序 换成了快排 
# 查询一个数是否能由数组里的数组成，能的话返回组合下标 
```js
//找出数组中两个数的组合等于制定数的组合
function find(arr,num){ 
       arr.sort((a,b)=>a-b)   
        let i=0;let j=arr.length-1   
         while(i<j){       
              if(arr[i]+arr[j]<num){          
                    i++      
              }  else if(arr[i]+arr[j]>num)     {           
                   j--       
             }     else {              
                   console.log(arr[i]+"+"+arr[j]+"="+num)              
                  i++;j--;        
            }   
         }
}
find([2,7,8,1,10],9)
```
# 返回字符串的最长不重复子串长度 
```js
function longeststr(s){   
     let str='';//当前最长字串    
     let lens=0;    
     let l=s.length    
     for(let i=0;i<l;i++){    
             char=s.charAt(i)       
              index=str.indexOf(char)      
               if(index===-1){           
                    str+=char            
                    lens=lens<str.length?str.length:lens       
                 }       
                  else{            s
                  tr=str.substr(index+1)+char        
                  }   
       } 
   return lens;
}
 console.log(longeststr('abcdeafghh'))
```
# 用正则把a字符串替换成b字符串,这个我不记得正则咋用了，跟他说用split，就用了split 
```js
a='use_xbox_serios_one'
b='useXboxSeriosOne'
c=a.split("_");
for(let i=1;i<c.length;i++){   
     temp=c[i][0].toUpperCase();    
     c[i]=temp+c[i].slice(1);   
      console.log(c[i])
}
d=c.join('')
console.log(d)
console.log(d==b) 
```
# 闭包里 return n=n+1
# children和childnotes区别
# Dom/Bom
# offsetleft offsettop
# substring slice区别
# 正则表达式四个api
**match**
**search**
**test**
# css grid
# http https  http1 http1.1  http2 http3
# 数据库 关联查询
# 防抖  节流
# 函数中有个对象，对象中有index=0，让实现函数每秒返回index++的值，后续又加了让我实现onchange监听index变化，我用defineproperty实现了，他又让我实现多个监听者
# 数组打乱顺序输出 
# 用css实现：当鼠标在div上时，在该div上方显示“你好”，我用了hover和伪元素实现的 
# 链表和数组区别
# 二分查找 
# 描述了一个题，其实就是幂函数，说了递归的实现，问有没有什么注意的？说了溢出，然后提示没有溢出，又提示我没考虑负数。。然后纠正了，然后问了复杂度。然后做了优化。。 
# 写一个函数每次调用输出会自增 1
# JavaScript 作用域
# Vue 双向数据绑定原理 
# 事件流，事件***，点击一个div 里面的一系列 li 弹出它的 innerHTML 怎么做？ li 里面还有子元素，比如 span 怎么处理？ 
# 从哪些方面提高网站的渲染速度？ 你刚才提到 GZip，具体怎么做
# 各种跨域。localStorage 也适用吗？（postMessage) 
# 排序算法知道多少种？适用场景是什么（有序性，数据规模，稳定性等）？冒泡什么时候复杂度最高？ 
# 轮播组件怎么无限滚动的
# 让你做一个日历组件的思路，你觉得里面用到了哪些算法知识，核心功能是什么。在项目中用其他组件或者库用的多吗
# http状态码01 和 302 区别？ 304 含义？304 原理？501 和 502 区别？ 
# git 用过是吧，git pull 和 git fetch 区别？哪个命令可以重命名分支？ 
# 前端打包工具都用过哪些，除了 webpack 呢？webpack 和 gulp有什么不同？ 
# 原生的 DOM 操作都有什么？增删改查都是哪些命令？
# rem
移动端适配怎么做？说到了淘宝的 flexiable 和 rem，又问知道 flexiable 的实现么？说了根据屏幕分辨率动态调整根元素的 font-size，又问还有呢？说了 viewport 又问还有吗。忘了。。 
# 手写一个对象拷贝
# == 和 === 的区别，及它们具体如何判断相等
# display属性（none, block, inline, inline-block）
# 算法：把两个有序数组合并成一个有序数组
# 算法：一个形如[[1,2],3]的数组展平成[1,2,3]（元素全为数字）（可以直接toString或者迭代？）
# bind\apply\call，区别，bind有几个参数？实现一个bind函数 
# v-model原理是
# margin塌陷是啥？解决方法？BFC的四种方法
# 重排和重绘都是什么？服务器想要获取一个元素的宽高，重排还是重绘？分情况
# 读代码
```js
const log()→{    
      var log=0;      
      var count=log++;       
      setTimeout(function(){
          console.log(count);
       }, math.random(10*1000%100));      
    }     
 log();      
 log();
```
# 如何实现可靠传输
# HTTPs保证安全传输
# 中间人攻击 DNS劫持
# 设计一个mock系统
# 二叉树中序递归和非递归
# 递归迭代区别
# 实现一个函数，这个函数有两个参数，一个参数是fn 一个是count 要求，参数fn是一个promise函数, 如果执行成功直接返回，如果失败就重试count次数，到达count之后就返回失败
```js
function tryFn(fn,count){  
    let mycount = 0;   
    return new Promise((resolve,reject)=>{          
         fn().then((res)=>{                resolve(res)           
          }).catch((err)=>{                    
              if(mycount == count){                               reject(err)                    }       else{                              tryFn(fn,mycount++);                    }            })  
             })}​然后在面试官的提醒下修改成了如下function tryFn(fn,count){        return fn().catch((err)=>{                return count?tryFn(fn,count--):Promise.reject(err):        })
```
# 登录权限控制如何实现
# www.baidu.com输入到浏览器到显示页面发生了什么 
# webpack打包拆包过程 
# 什么时候发送预检请求，预检是否携带cookie 
# 摘要加密是什么，运用场景 
# 如何判断链表有环，找出其入口（算法题） 
# vnode如何生成，具体实现过程，v-if和v-for会解析成什么格式 
# 算法
```js

list = [['大份'，'中份','小份'],['微辣','重辣'],['微麻','中麻']] // 商家可能会自主增删调整各项配置
function compose () {   
     // code => ['大份+微辣+微麻'，'大份+重辣+微麻'，……] 所有组合
 }
 compose(list)
```
# Object.freeze
如何限制Person对象新增其他属性 
Person = {
    age: 'zhangsan'
}
# f（）调用一次输出1，第二次调用输出2
# m的n次方优化
# 说一下Redux 
# Redux异步怎么解决的 
# React-router原理 
# webpack优化 
# webpack打包原理 
# 数据库事务的特点  一旦改变 不可撤销
# 死锁是什么  死锁的必要条件  怎么解决死锁 
# 先获取到url的查询字符串，然后写一个函数，我传入一个参数，返回这个参数对应的查询字符串的value 
#  一行代码实现***数组的拍平然后去重然后升序排列 
# 手写归并排序 
# git回滚 
# 在我美团的域名下，假如说是meituan.com下localStorage存满了，因为有很多团队和业务都要写，那么写满了，这个时候怎么办 
# 场景题：你在北京写好了项目，测试没问题，但是在哈尔滨的用户反映说白屏怎么解决？（让我从数据链路层和物理层着手考虑。。。就是底层。。。） 
# 用过cdn？哦，那你说一下cdn底层原理。 
# 写斐波那契数列 
# 为什么js是单线程的
# 怎么用flex画一个三个点的骰子
# 手撕二叉树广度优先遍历 
# 怎么判断两个链表的交点
# 文档过期时间怎么设置
# 怎么设置一个在PC端与手机端都可以浏览的页面
# JS模块化，AMD,CMD。。。
# 骨架屏的实现方式
# ssr
# 编程题
```js

// 改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。
for (var i = 0; i< 10; i++){    
     setTimeout(() => {
          console.log(i); 
      }, 1000) }
 for (let i = 0; i< 10; i++){     
     setTimeout(() => {
          console.log(i); 
     }, 1000 * i) 
}
```
# 算法
```js
// var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; // 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组
 function flat(arr) {    
     let newArr = arr.toString().split(",")    newArr = [...new Set(newArr)];   
     newArr.sort((a, b) => {return a - b})    return newArr
}
```
# 图片的格式分为几种？有什么区别？听过webp吗？
# CSS3的动画最小间隔多少（多数显示器的默认频率是60Hz，每秒刷新60次，最小间隔是16.7ms）
# 网络如何保证不丢包
# 视频用TCP还是UDP，如果用UDP，丢包怎么办 UDP尽最大努力传输，丢了就丢了
# 原生JS绑定、解绑DOM元素事件(onclick)。如果要绑定多个事件呢？(指onclick绑定多个触发函数)
# Promise：连续两次执行promise.then()的情况。
# 数组去重
# box-sizing有哪些值？代表了什么？然后出了个题让你判断背景颜色的宽度
# 三栏布局
# 两栏布局
# 两边自适应中间定宽。三个块垂直居中怎么实现（直接写css）
# 算法

二维数组排列组合： 输入：[[A, B], [a, b], [1, 2]] 输出：[Aa1, Aa2, Ab1, Ab2, Ba1, Ba2, Bb1, Bb2] 用了递归实现。借鉴了哈夫曼树的构建算法
# 大数相乘
# 如何实现分页器
# 移动端实现1px
# 判断是否是数组

如何判断函数参数是否为数组？如何判断对象？ES6如何判断？   
Array.isArray() //ES5加入的方法，判断是否为数组，ES6同样适用   
 Object.prototype.toString.call() //判断数组和对象，ES6加入symbol数据类型后，结果不准确    instanceof //判断数组和对象，问题在于假定只有一个全局执行环境，除此之外也有ES6加入symbol数据类型后，结果不准确的问题    
  typeof //判断对象 1(typeof param === 'Object' || typeof param === 'Function') && param !== null

  # 箭头函数和普通函数的区别 
  ```js

this.a = 20;var test = {    a: 40,    init: () => {        console.log(this.a);        function go() {            this.a = 60;            console.log(this.a);        }        go.prototype.a = 50;        return go;    }};var p = test.init();p();
```
控制台输出结果以及原因 
输出：20 60 
# ES6 var let const 定义变量的区别

var 函数作用域，已声明未初始化时是undefined      let 块作用域，无提升，声明变量一定要在声明后才能引用，不允许重复声明，暂时性死区     const 块作用域，无提升，一旦声明需立即初始化，暂时性死区，声明变量时表示保存地址不变，指向的数据结构可变



let d = 2;const e = 10;(function () {    var a = b = 5;    d = 3;    let e = 11;})()console.log(b);console.log(d);console.log(e);console.log(a); 控制台输出结果以及原因    输出：5 3 10 ReferenceError: a is not defined    需要注意的是，以下两种写法是等价的 1234var a = b = 5; var a = b;b = 5;

# getUrl
```js

//let url = 'http://www.meituan.com/?user=janechang&id=325&city=wuhan'
//实现parseParam(url)返回
// {
//    user: janechang,
//    id: 325,
//    city: wuhan
//}
```
# 最快查找数组
//请写出最快查找数组[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]中31出现的位置
function findPos(arr, item){};
写了个二分查找 
# 函数柯里化
柯里化sum（1）（2）（3）
# echart的优化问题 
# 二叉树的中序遍历实现  分析递归算法的时间复杂度
```js

// Way1. 栈结构实现function inOrder(root) {    var res = [];    var stack = [];    var p = root;    while (p || stack.length > 0) {        while (p) {            stack.push(p);            p = p.left;        }        p = stack.pop();        res.push(p.node);        p = p.right    }    return res} // Way2. 递归实现function inOrderCore(root, res) {    if (!root) {        return     }    inOrderCore(root.left, res);    res.push(root.node);    inOrderCore(root.right, res);} function inOrder2(root) {    var res = [];    inOrderCore(root, res);    return res;}
```

#  二叉树的节点为N，那么二叉树的深度为多少，怎么推导的。。（logN） 
```js

function dfs(root) {    if (!root) {        return 0    }else {        var leftDepth = dfs(root.left);        var rightDepth = dfs(root.right);        var childDepth = leftDepth > rightDepth ? leftDepth : rightDepth;        return childDepth + 1    }}
```
# 闭包和JS垃圾回收机制 利用闭包实现按列升降序排序函数（0表示升序，1表示降序） 
```js

function listSort(testArr, str) {  
      return function (sortWay) {        // 比较       
      if (sortWay) {            
          testArr.sort((a, b) => {return b[str] - a[str]})        
      }else {            
          testArr.sort((a, b) => {return a[str] - b[str]})        
      }        
    return testArr    
}} 
var testArray = [{name: 1,age: 18,mobile: 123},{name: 2,age: 19,mobile: 234},{name: 3,age: 20,mobile: 456}]; 
console.log(listSort(testArray, "name")(1));
```
#  Generator的\*表示什么意思，如果在yield后加\*号表示什么
# 非父子组件传值，说了Eventbus、vuex还有什么 
# computed watch 
# 组件传值
# http  https  ssl  tsl的区别
# mongdb几个重要概念，关系型，非关系型数据库区别（说到了虚拟内存，那么什么叫做虚拟内存......)
# margin塌陷
# 层叠上下文 
# 二叉树  完全二叉树  满二叉树   n阶满二叉树的节点
# 链表是什莫         冯诺依曼结构
# 数据量庞大时候的项目优化情况
# EventEmitter
# 移动端click 300ms延迟的原因 
# 算法：两个数组的交集，并集 
# v-for为什么要加key值。
# 虚拟dom和diff算法 
# set去重原理
# react的setState后发生了什么
# 数组右移x位
# 给一个数组，给一个数x，找数组内想加等于x的数的索引
# 识别登录状态 
# 原型链
# react 高阶组件 
# koa 中间件原理，洋葱模型 
# 设计中间件，记录错误并写入文件
# webpack alias，如何不给某些文件加后缀 
# 场景题 => 你的手机端可以显示页面，领导的就不行，怎末解决 => 考察实际解决问题思维
# 算法题：打开Excel表格，表头上有A，B...Z，AA，AB... ，输入A，输出B，输入AB，输出AC，输入ABC，输出ABD，输入Z，输出AA。
# promise
Promise( {
Resolve(1);
Reject(2);
}).then(e=>{
Console.log(e); 
....... 
})
# 给定方法，不可以用console.log  

 const log = (callback) => {        log.count = log.count || 0;        var count = log.count++;        setTimeout(()=>{                     console.log(count);                     callback && callback();     }, Math.random()*1000%10); }

用这个log方法输出0-100 ； 

var test = function () {
    if (log.count == 101) {
        return;
    }
    log(test);
}
log(test);

# z-index
# css取消点击事件 哪个属性
# setTimeout(xxx,0)
# jwt
# 随机算法
# 打印二叉树的左视图
# 如何在Chrome里实现12px以下的字号？（说了transform: scale()，面试官说还比较常用SVG）
# 跨域了解吗？被跨域屏蔽掉的请求是完全发不出去还是能发出去只是拿不到响应？如何解决跨域？
**跨域并不是请求发不出去，请求可以发出去，服务端能够收到请求，并且正常返回结果，只是被浏览器拦截了**
通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了



# 手写个JSON.parse的polyfill
# Chrome审查元素功能实现原理 实现谷歌浏览器的元素审查功能 

# ie兼容性问题-在ie下捕获事件的方法，取消冒泡的方法
# 说一下setTimeout与requestAnimationFrame的区别
# 说一下js事件轮询
# requestAnimationFrame如何实现每秒60次的回调
# 算法

场景题，一个按钮和一个展示区域，点击按钮会发送请求，将响应结果展示到展示区域，如果双击按钮，发送两个请求，先发送的请求响应时间比后发送的长，导致后发送请求的响应先到达，如何实现在展示区域仍按点击的顺序来展示内容？
# 一个二维数组，里面只有0和1,1代表陆地，0代表海，1的上下左右四个方向如果有1，则他们属于同一个岛，求岛的数目。
# 身份管理如何实现 token失效怎么处理
# fetch
# cookie 怎么禁用、cookie跨站共享
# 前端和后端如何鉴权 
# 原型链 Object.create() 枚举特性，遍历以及for in 方法，hasOwnProperty() 方法
# 类数组，如何转化为数组，有几种方法
# vi 编辑器有几种模式，如何写，如何退出，如何插入，如何跳转到具体某一行
# git 如何拉取某个文件夹
# Redux和dva的区别 
# padStart用过嘛 来实现一下
# Git的基本操作 有冲突怎么办 
# 什么时候用Java什么时候用node
# 手写url解析 
# 手写递归非递归的dfs 
# 手写圣杯布局 
# 登陆注册流程 
# dns原理 
# 手写文件目录查找
# bootstrap的布局，如何实现响应式布局
# 隐式转换规则
# mvc mvp mvvm 的区别
# 二叉树的反转
# 数据库索引 
# 局部有序数组的查找
# node的流的概念
# css

手写布局，上面header，下面footer，中间body不定高，纯css让body高度比较小的时候，在中间，footer固定底部。当body比较高，超过屏幕范围，让body在屏幕下面同时footer紧跟body下面。
# 实现柯里化f(1)(2)(3)(4)(5)(6)(7)(8) == sum(1,2,3,4,5,6,7,8) 
# koa的中间件怎么写？原理了解吗？
# egg相对于koa做了哪些优化
# 删除一个链表的节点p怎么做 前提是你只知道p节点，其他节点包括头节点都不知道
# 给你一个m*n的二维数组，该数组每个值不重复，值规律是横向增大纵向增大。此时给你一个数你找出该数位置，怎么做
# 一个算法题，就是类似于二分查找法查找给定元素下标 
# 用闭包解决类似这个问题，很常见的问题。
function count() { var arr = []; for (var i=1; i<=3; i++) {        arr.push(function () { return i * i;        });    } return arr;}
# 手写一个两个有序数组合并成一个（其实就是归并排序），分析复杂度
# 插入排序复杂度分析，快排最好最坏情况复杂度，什么情况最坏。
# 求数组里加和最大的连续子数组的和
# 写个列表，里面每一条绑定点击输出内容的事件，为什么绑到了父节点。
# 一个简单的类似字符串翻转的算法，手写一下
# getElementsByClassName 和 querySelectorAll 的区别，说了一个传的选择器，一个字符串，然后问返回值呢，没有答上来，查了一下一个返回的是 Static Node List，一个返回的是 Live Node List
# 一个场景：云笔记，用户手机端，pc 端，pad 端分别同步了，然后 pc 端，pad 端断网，分别修改，然后一个先联网一个后联网，冲突怎么处理。（提示从数据结构考虑，感觉可能用栈处理好一点，然后又问设计哪几张表，分别有哪些字段
# 手写动态规划（青蛙跳） 
# 手写深拷贝 
# 为什么会有同源策略
# flex：1代表什么？（flex: 1 1 0%） 
# socket是怎么握手的
# MVC和MVVM的区别。    MVC ，用户操作> View (负责接受用户的输入操作)>Controller（业务逻辑处理）>Model（数据持久化）>View（将结果通过View反馈给用户）    MVVM是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上
# 如何实现双向数据绑定。 
大体上就是使用Object.defineProperty()劫持数据，使得数据驱动视图。 
使用事件监听，使得视图改变数据。
# GC 


V8主要基于分代式垃圾回收算法    新生代：Scavenge算法（具体实现为Cheney算法） From空间和To空间balabala    新生代到老生代晋升的条件:1.对象是否经历过Scavenge回收 2.To空间内存占用比超过限制    老生代：Mark-Sweep &Mark-Compact  balabala    此外还有Incremental Marking解决全堆垃圾回收太长，后续又引入了延迟清理、增量式清理，以及并行标记与并行清理。
# 在数组上设计一个查找两个数组里相同元素的方法
# 十进制转化二进制后1的个数 
# 最大连续子序列和
# 求多叉树最大深度
# window.onload和image.onload那个先执行
# 属性值没有放在data中的话更改后会被重新渲染吗，属性值在data中，但是属性值是由其他没在属性data中的值获得的，如a在data中，但是a=b+1，b没在data中
b改变了，a会改变吗 
# 比较两个对象是否有出入

```js
function differ(obj1,obj2){             
    var a1 = obj1 instanceof Object;             
    var a2 = obj2 instanceof Object;    
    //判断类型             
    if(!a1 || !a2){                 
        return obj1 === obj2;             
    }           
    //判断长度             
    if(Object.keys(obj1).length !== Object.keys(obj2).length){                 
         return false;             
    }             
    //一次比较每个内部的属性是否相等             
    for(var attr in obj1){                 
        var t1 = obj1[attr] instanceof Object;                 
        var t2 = obj2[attr] instanceof Object;                 
        if(t1 && t2){                     
            return differ(obj1[attr],obj2[attr]);                 
        }else if(obj1[attr] !== obj2[attr]){                     
            return false;                 
        }             
    }            
    return true;         
}
2.

let obj =  {a:{b:1}};  
function getValue(obj,str,flag){     
    var arr = str.split(".");     
    var arr1 = arr[0];     
    var a = obj[arr1];     
    var arr2 = arr[1];     
    var b = a[arr2];     
    if(b!=='undefined'){         
        return b;     
    }else{         
        return flag;     
    } 
} 
console.log(getValue(obj,'a.b',0));

有出入 一个是遍历了对象的属性值是否相等
另一个直接比较
```

# 盒模型，bfc 
**box-sizing:border-box使用场景，响应式布局的时候是根据百分比换算计算元素的宽高，不考虑边框很好做，要是考虑边框的时候，使用border-box来布局，border会自动计算到width里面，form表单**
box-sizing的属性值有两个，分别为border-box;content-box;
border-box；这个属性的总宽度是由内容宽度加内边距宽度再加上边框的宽度
（width=content+padding+border）
content-box；它的宽度就是内容的实际宽度，
border-box属性在form上的使用
当我们要做一个登陆页面的时候，这时候就需要表单和按钮这些元素
首先我们在一个div中设置两个表单，一个用来输入用户名，一个用来输入密码，同时还有有一个登录按钮，
当我们想让这两个表单与一个登录按钮的长度相同时，这时我们试着把它们三个的width的值都设置为100%

这里看到它们三个的width都设置为100%，而它们的长度并不一致，由此可以看出表单和按钮的padding、border值不统一，这时我们给表单的属性中添加一个
box-sizing：border-box；此时表单和按钮的长度保持一致。
当不给表单添加box-sizing：border-box；属性时，而是添加一个padding值会发现表单长度宽度都有所增加。
当给按钮添加padding时它的长度并不会改变。由此可以看出表单默认content-box，按钮submit默认border-box，button的默认值也为border-box。



# 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景
**flex 是 Flexible Box 的缩写，意为”弹性布局”，采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。 它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。 项目默认沿主轴排列。**

**父元素**
- flex-direction属性决定主轴的方向（即项目的排列方向）。 
- flex-wrap属性定义，如果一条轴线排不下，如何换行。默认情况下，项目都排在一条线（又称”轴线”）上。 
- flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap 
- justify-content属性定义了项目在主轴上的对齐方式。 
- align-items属性定义项目在交叉轴上如何对齐。 
- align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。


**子元素**
- order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 
- flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 
- flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 
- flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 
flex属性是以上三个的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 
align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch 


flex:1 表示   flex:0 1 auto;表示的是flex-grow：项目的放大比例 flex-shrink flex-basis分配多余空间之前项目占据的主轴空间 默认auto项目本来的大小

flex属性默认是0 1 auto
flex-grow为0，则存在剩余空间也不放大  
flex-shrink为1，则空间不足该项目缩小
flex-basis为auto，则该项目本来的大小

# react的虚拟dom了解多少？这种类型的框架和传统的jq操作dom的优势？ diff算法？说了一下虚拟dom如何实现，diff算法做了什么优化
# 手写镜像二叉树算法
# js实现哈希表存储算法（要求key可以存储对象）
# 事件委托，点击 ul 中的li 弹出li内容，动态添加li 
# 重建二叉树（剑指offer）
```js


```
# 算法：给一串字符串，写出它的全排列
**方法一**
全排列，计算有n个字符，排列组合，有n!种,当n<=1此时返回数组本身，n>1分成n，n-两种情况考虑递归如何产生，假如当 n = 1，即传参 str 的长度只有1时，则直接返回只有 str 的数组；当 n > 1时，则考虑 n 和 n - 1 方法返回数组的关系。可以想到，n 时多出的一个字符，来添加到 n - 1 返回数组中每个字符串的头部。

```js
var prem = function(str) {
    // 接收全排列的数组
    var res =[]
    if(str.length<=1) {
        return [str];
    } else {
        for(var i=0; i<str.length; i++) {
            var temp = str[i];
            var newStr = str.slice(0,i)+str.slice(i+1,str.length);
            var l=prem(newStr);
            for(var j=0; j<l.length; i++) {
                var tmp = temp+l[j];
                result .push(tmp);
            }
        }
    }
    return result;
}
```
**方法二**
当字符串长度为1时，输出该字符串；
当长度大于1时，取字符串的首字母，求出长度-1的串的全排列，将首字母插入每一个排列的任意位置。
```js
function permutate(str) {
    //保存每一轮递归的排列结果
    var result = [];
    //初始条件：长度为1
    if (str.length == 1) {
        return [str]
    } else {
        //求剩余子串的全排列,对每个排列进行遍历
        var preResult = permutate(str.slice(1));
        for (var j = 0; j < preResult.length; j++) {
            // 加1是让字符可以插入到其他位置



            for (var k = 0; k < preResult[j].length + 1; k++) {
                //将首字母插入k位置  
                var temp = preResult[j].slice(0, k) + str[0] + preResult[j].slice(k);
                result.push(temp);
            }
        }
        return result;
    }
}

var prem = function(str) {
    var res=[];
    if(str.length<=1) {
        return [str];
    }else {
        var result = prem(str.slice(1));
        for(var i=0; i<result.length; i++) {
            for(var j=0; j<result.length+1; j++) {
                var temp = result[j].slice(0,j)+str[0]+result[j].slice(k);
                res.push(temp);
            }
        }
    }
    return res;
}
```
**尾递归**
函数的第一个参数是本次递归的字符串，第二个参数是前x个字符的全排列结果。
思路是：
每次取当次递归串的第一个字母；
若第二个参数长度为0说明是第一次递归，则初始化本次结果为[首字母]。然后将首字母从递归串中剔除，剩余串传给下一次递归;
之后每一次递归，都取递归串的首字母，将其插入前x个字符的全排列的所有位置，求出x+1个字符的全排列；
递归直到第一个参数为空串，则第二个参数为字符串所有字符的全排列。
可能不太好理解，不过知道这是尾递归就行了。虽然尾递归在ES6的严格模式中才有效，但是，我加上'use strict';后仍然无效。事实上我认为并不是函数调用栈的溢出，而是存放变量的堆溢出。所以，大概是无解了吧。毕竟全排列不管怎么样，空间复杂度都是O(n!)的。
```js
function permutate(str,result) {
    'use strict';
    let tempArr = [];
    //终止条件str长度为0
    if (str.length == 0) {
        return result
    } else {
        //第一次递归时，插入首字母
        if(result.length === 0){
            tempArr.push(str[0]);
        }else{
            for (let i = 0; i < result.length; i++) {
                let item = result[i];
                let itemLen = item.length;
                for (let j = 0; j < itemLen+1; j++) {
                    let temp = item.slice(0, j) + str[0] + item.slice(j);
                    tempArr.push(temp);
                }
            }
        }
        //递归截取了第一个字符的子串
        return permutate(str.slice(0),tempArr);
    }
}
permutate("abcdefghijkl",[]);
```
**循环**
```js
function perm(str) {
    let result = [],tempArr = [];
    let subStr = str;
    while (subStr.length !== 0) {
        if (result.length === 0) {
            result.push(str[0]);
        } else {
            for (let i = 0; i < result.length; i++) {
                let item = result[i];
                let itemLen = item.length;
                for (let j = 0; j < itemLen+1; j++) {

                    let temp = item.slice(0, j) + subStr[0] + item.slice(j);
                    tempArr.push(temp);
                }
            }
            result = tempArr;
            tempArr = [];
        }
        subStr = subStr.slice(1);
    }
    return result;
}

function prem(str) {
    var res=[];
    if(str.length<=1) {
        return [str];
    }else {
        var result = prem(str.slice(1));
        for(var i=0; i<result.length; i++) {
            for(var j=0; j<result.length+1; i++) {
                var temp= result[j].slice(0,k)+str[0]+result[j].slice(j);
                res.push(temp);
            }
        }
    }
    return res;
}
```

# 异步取到的数据，动态的添加一些列表，怎么给这些列表动态的绑定点击事件？ 
事件委托
# 变量提升
```js
var a = 0;            
function B(){
    var a; // undefined;                
    console.log('1',a);                
    var a = 3;                
    console.log('2',a);                
    return function(){                    
        console.log('3',a++);                
    }            
}           
var C = B();            
C();  
// 1 undefined
// 2   3
// 3 3 使用自增前的值   再次执行+1
``` 
每个a打印的值 
# md5实现原理。
是不可逆的。 
很多网站数据库里存放的是密码的md5值。 
但是md5还是很容易被破解的，因此有了加盐一说法。 
关于加盐可以看这里
https://blog.csdn.net/blade2001/article/details/6341078
# 1000个数找到2个数和为100的所有数
时间复杂度O(nlogn)
```js
function allNums(arr,target) {
    if(!arr || arr.length>1000) {
        return false;
    }
    let l=0;
    let r=arr.length-1;
    while(l<r) {
        if(target===arr[l]+arr[r]) {
            res.push(arr[l]);
            res.push(arr[r]);
            // console.log(arr[l]+"+"+arr[r]+"="target)
            l++;
            r--;
        }else if(target>arr[l]+arr[r]) {
            l++;
        }else {
            r--;
        }
    }
    return res;
}
```
**暴力枚举法**
```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    var arr = nums;
    
    for(var i=0;i<arr.length;i++){
        var index = arr[i];
        var other = target - index;
        for(var j=arr.length; j>i;j--){
            if(arr[i] + arr[j] == target){
               return [arr[i], arr[j]);
           }
        }
    }
    return [-1, -1];
};

```
# 计算出页面上div的最深层，也就是图的深度遍历，记录下每条路径的长度，然后找出最大值。
# css的img是什么元素，能定义宽高吗，周围文字是在下一行展示还是围绕展示
css的img是行内元素，不会独占一行，img可以设置宽高，因为img既是行内元素也是置换元素，置换元素可以根据标签属性来显示的元素，常见的置换元素包括input,textarea,,select，置换元素可以内置宽高
```js
<style>
   .box{
    width:600px;
    border:1px solid rgba(233,156,76,0.9);
    font-size: 15px;
   }
</style>
<body>
<div class="box">
     <img src="QQ_icon.jpg" alt="QQ.jpg"  width="60" height="70">
     中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法中文輸入法
</div>
</body>

```
**怎样对文字进行强制换行？**
word-break:break-all;

**允许长单词换到下一行**
word-wrap:break-word;


# translate tranform transition animation各是什么，有什么区别 
- animation:css3的动画属性，使用@keyframes，绑定到关键帧来表示动画的过渡用@keyframes定义自定义动画，用animation引用该动画。最简单的写法：animation：name（自定义动画名称） duration（持续时间）;例：animation：scroll 2s;意思是在2s内运行自定义的scroll动画。
- transition：过度效果，是需要事件触发的，from to需要两帧。使css属性在一段时间内平滑过渡。最简单写法：transition：property（需要过渡的属性） duration（持续时间）;例：transition：background-color 2s;意思是用2s时间过渡背景颜色。该属性比animation低级一些。不能自定义动画，只是模拟,transition允许在一定的事件平滑的过度
- translate位移，是transform变换属性的一种，transform:translate(100px) x轴平移100px
# 实现队列中添加一个数字并推出一个最大的数
```js
// 定义一个空队列
let queue =[]
// 保存最大的数
let maxQueue = []
// 记入下标
let index;

function push_queue(number) {
    if(maxQueue.length>0 && number>maxQueue[maxQueue.length-1].number) {
        maxQueue.pop();
    }
    let item = {
        number:number,
        index:index
    }
    index++;
    maxQueue.push(item)
    queue.push(item)
}

function pop_queue() {
    if(queue.length===0) {
        return;
    }
    if(queue[0].number===maxQueue[0].number) {
        maxQueue.shift()
    }
    queue.shift();
}
function max() {
    return maxQueue[0].number;
}
```


**自己的方法**
```js
let queue=[]
let maxQueue=[]
let index=0
// 入队
function push_queue(number) {
    // 如果入队的数字，比maxQueue还打，maxQueue出队
    if(maxQueue.length>0 && number>maxQueue[maxQueue.length-1].number) {
        maxQueue.pop();
    }
    let item = {
        number:number,
        index:index
    }
    index++;
    // 压入maxQueue队列
    maxQueue.push(item)
    queue.push(item);
}

function pop_queue() {
    // 如果队列空的
    if(queue.length===0) {
        return;
    }
    if(queue[0].number===maxQueue[0].number) {
        maxQueue.shift()
    }
    queue.shift();
}
function max() {
    return maxQueue[0].number;
}

class Queue {
    constructor() {
        this.queue=[]
        this.init=init
    }
    // 入队
    unshift(element) {
        this.queue.push(element)
    }
    // 出队
    shift() {
        this.queue.shift()
    }
    init() {
        this.unshift();
        this.shift();
    }
    toString() {
        return this.queue;
    }
    max() {
        return Math.max(this.queue)
    }
}
var q = new Queue();
q.unshift('6')
```


# 从一个ajax发起的过程，到后台连接数据库，到数据库建表关联查询，设置主键外键，sql语句的书写全过程，手写实现主要步骤
mysql数据库
# display:inline-block和float区别
display:是指显示状态，float是针对块级元素的浮动
使用display:inline-block:控制元素的垂直对齐跟横向排列
float:让元素环绕一个元素
inline-block元素带有一些行内元素的特征（横向排列），同时内部也拥有块级元素的属性。这个跟浮动很类似，只不过有些区别，这些区别决定了你该使用哪种方案。  如果你很纠结垂直对齐问题或者横向排列元素，不妨使用inline-block。如果你需要对一个元素跟围绕他的一些元素进行更多控制，你需要浮动�� 当然，table也是你处理一些问题的最佳方案。



# base64的原理 
**base64是一种用64个字符对二进制数据进行编码的算法，常用于base64加密，电子邮件加密，规避反垃圾邮箱工具，图片文件网络传输**
**编码过程**
 base64编码，每3个8位明文数据为一组，取这3个字数据的ASCII码，然后以6位为一组组成4个新的数据。对于不足3字节的处理：
【1】不足三字节后面填充0；
【2】对于编码前的数据产生的6位，如果为0，则索引到的字符为‘A’；因不足3字节而填充的0，用’=’来替代，有点结束符的意思。
例如对“ABCD”进行base64编码：
对于不足6位的补零（图中浅红色的4位），索引为“A”；对于最后不足3字节，进行补零处理（图中红色部分），以“=”替代，因此，“ABCD”的base64编码为：“QUJDRA==”

I**解码过程**
base64解码，即是base64编码的逆过程，如果理解了编过过程，解码过程也就容易理解。将base64编码数据根据编码表分别索引到编码值，然后每4个编码值一组组成一个24位的数据流，解码为3个字符。对于末尾位“=”的base64数据，最终取得的4字节数据，需要去掉“=”再进行转换。
解码过程可以参考上图，逆向理解：“QUJDRA==” ——>“ABCD”

**工具**
https://tool.oschina.net/encrypt?type=3



# 表单上传图片的请求格式是怎样的
上传图片使用webupload LUploade插件，支持图片预览/分片上传，功能丰富
**表单上传图片**
<form id="addform" class="form-horizon" method="post" action="" enctype="mutipart/form-data" target="iframe">
    选择文件:<input id="file" type="file" name="pic" onchange="aa()" />
    <input id="submit" type="submit" value="上传" />
</form>
<form id="iframe"></form>

**enctype必须为mutipart/form-data**
enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。默认地，表单数据会编码为 "application/x-www-form-urlencoded"。就是说，在发送到服务器之前，所有字符都会进行编码。HTML表单如何打包数据文件是由enctype这个属性决定的。enctype有以下几种取值：
application/x-www-form-urlencoded：在发送前编码所有字符(默认)(空格被编码为’+’，特殊字符被编码为ASCII十六进制字符)。

multipart/form-data：不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。
text/plain：空格转换为 “+” 加号，但不对特殊字符编码。
默认enctype=application/x-www-form-urlencoded，所以表单的内容会按URL规则编码，然后根据表单的提交方法：
method=’get’ 编码后的表单内容附加在请求连接后，
method=’post’ 编码后的表单内容作为post请求的正文内容。

(3).提供input type="file"上传输入域。
2.ajax无刷新上传 
ajax和FormData可实现页面无刷新的文件上传效果，主要用到了jQuery的ajax()方法和XMLHttpRequest Level 2的
FormData接口。通过FormData对象可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart/form-data ，则通过FormData传输的数据格式和表单通过submit()方法传输的数据格式相同。


ajax无刷新上传
Ajax无刷新上传的方式，本质上与表单上传无异，只是把表单里的内容提出来采用ajax提交，并且由前端决定请求结果回传后的展示结果。
3.各类插件的使用：
webupload LUPloader



# js单链表反转
**递归**
```js
function reverseLinkList(head) {
    if(!head && head.next===null) {
        return head;
    }
    var l1 = head.next;
    var l2 = reverseLinkList(l1);
    l1.next=head
    head.next=null;
    return l2;
}

var reveseList = function(head) {
    if(head==null || head.next==null) {
        return head;
    }
    var l1 = head.next;
    var l2 = reverseList(l1);
    l1.next=head;
    head.next=null;
    return l2;
}
``` 
```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    if(head == null || head.next == null) {
        return head;
    }
    var l1 = head.next;
    var l2 = reverseList(l1);
    l1.next=head;
    head.next = null;
    return l2;
};
```

**非递归，迭代**


# 布局
header
left  right